- [关系数据结构及形式化定义](#关系数据结构及形式化定义)
  - [关系](#关系)
    - [域（domain）](#域domain)
    - [笛卡尔积（cartesian product）](#笛卡尔积cartesian-product)
    - [关系（relation）](#关系relation)
  - [关系模式](#关系模式)
- [关系操作](#关系操作)
  - [基本的关系操作](#基本的关系操作)
  - [关系数据库语言的分类](#关系数据库语言的分类)
- [关系的完整性](#关系的完整性)
  - [实体完整性](#实体完整性)
  - [参照完整性](#参照完整性)
  - [用户自定义的完整性](#用户自定义的完整性)
- [关系代数](#关系代数)
  - [传统的集合运算](#传统的集合运算)
    - [并（Union）](#并union)
    - [差（Difference）](#差difference)
    - [交（Intersection）](#交intersection)
    - [笛卡尔积（Extended Cartesian Product）](#笛卡尔积extended-cartesian-product)
  - [专门的关系运算](#专门的关系运算)
    - [选择（Selection）](#选择selection)
    - [投影（Projection）](#投影projection)
    - [连接（Join）](#连接join)
      - [等值连接（Equijoin）](#等值连接equijoin)
      - [自然连接（Natural Join）](#自然连接natural-join)
        - [悬浮元组](#悬浮元组)
        - [外连接（Outer Join）](#外连接outer-join)
        - [左外连接（Left Join）](#左外连接left-join)
        - [右外连接（Right Join）](#右外连接right-join)
    - [除（Division）](#除division)
- [关系演算](#关系演算)
  - [元组关系演变运算语言ALPHA](#元组关系演变运算语言alpha)
  - [元组关系演变运算](#元组关系演变运算)
  - [域关系演变运算语言QBE](#域关系演变运算语言qbe)

# 关系数据结构及形式化定义

## 关系

- 关系模型的数据结构非常简单，只包含单一的数据结构 —— 关系
- 在用户看来，关系模型中数据的逻辑结构是一张扁平的二维表。
- 在关系模型中，现实世界的实体以及实体间的各种联系均用关系来表示。
- 关系模型建立在集合代数的基础上

### 域（domain）

- 是一组具有相同数据类型的值的集合
- 例如：自然数、整数、实数、{男, 女}...

### 笛卡尔积（cartesian product）

笛卡尔积是域上的一种集合运算。
给定一组域$D_1, D_2, \dotso, D_n$，允许其中某些域是相同的。 该一组域的笛卡尔积为：
$D_1 \times D_2 \times \dotso \times D_n＝ \{(d_1, d_2, \dotso, d_n) \: | \: d_i \in D_i, \: i＝1, 2, \dotso, n \}$

- **n-元组（n-turple）**：简称元组，笛卡尔积的一个元素 ——$(d_1, d_2, \dotso, d_n)$
- **分量（component）**：笛卡尔积的一个元素的每一个值 ——$d_i$
- **基数（cardinal number）**：一个域允许的不同取值个数，
  - 若$D_i(i＝1, 2, \dotso, n)$为有限集，其基数为$m_i(i＝1, 2, \dotso, n)$，则$D_1 \times D_2 \times \dotso \times D_n$的基数为：
  - $M = \prod_{i = i}^{n}m_i$

**笛卡尔积的表示方法**：

- 笛卡尔积可表示为一张二维表
- 表中的每行对应一个元组
- 表中的每列对应一个域

**示例**：
- $D_1$= 导师集合SUPERVISOR = {张清玫，刘逸}
- $D_2$= 专业集合SPECIALITY = {计算机专业，信息专业}
- $D_3$= 研究生集合POSTGRADUATE = {李勇，刘晨，王敏}
- $D_1 \times D_2 \times D_3 =${ (张清玫，计算机专业，李勇)，(张清玫，计算机专业，刘晨)，
  $\qquad\qquad\qquad\qquad$(张清玫，计算机专业，王敏)，(张清玫，信息专业，李勇)，
  $\qquad\qquad\qquad\qquad$(张清玫，信息专业，刘晨)，(张清玫，信息专业，王敏)，
  $\qquad\qquad\qquad\qquad$(刘逸，计算机专业，李勇)，(刘逸，计算机专业，刘晨)，
  $\qquad\qquad\qquad\qquad$(刘逸，计算机专业，王敏)，(刘逸，信息专业，李勇)，
  $\qquad\qquad\qquad\qquad$(刘逸，信息专业，刘晨)，(刘逸，信息专业，王敏) }
- $M = 2 \times 2 \times 3 = 12$
- 表格表示：

  | SUPERVISOR | SPECIALITY | POSTGRADUATE |
  | ---------- | ---------- | ------------ |
  | 张清玫     | 计算机专业 | 李勇         |
  | 张清玫     | 计算机专业 | 刘晨         |
  | 张清玫     | 计算机专业 | 王敏         |
  | 张清玫     | 信息专业   | 李勇         |
  | 张清玫     | 信息专业   | 刘晨         |
  | 张清玫     | 信息专业   | 王敏         |
  | 刘逸       | 计算机专业 | 李勇         |
  | 刘逸       | 计算机专业 | 刘晨         |
  | 刘逸       | 计算机专业 | 王敏         |
  | 刘逸       | 信息专业   | 李勇         |
  | 刘逸       | 信息专业   | 刘晨         |
  | 刘逸       | 信息专业   | 王敏         |

### 关系（relation）

笛卡尔积$D_1 \times D_2 \times \dotso \times D_n$的子集，叫作在域$D_1, D_2, \dotso, D_n$上的关系
表示为：$R(D_1, D_2, \dotso, D_n)$

- **元组**：关系中的元素，用$t$表示
- **关系名**：$R$
- **关系的目或度（Degree）**：$n$
  - $n = 1$时，该关系称为单元 / 一元关系（unary relation）
  - $n = 2$时，该关系称为二元关系（binary relation）

**关系的表示方法**：

- 笛卡尔积的子集，也是一个二维表
- 表的每行对应一个元组
- 表的每列对应一个域

**属性（attribute）**：关系中不同列可以对应相同的域，为了加以区分，必须对每列起一个名字，称为属性。$n$目关系必有$n$个属性。

**码（key）**：

- **候选码（candidate key）**：关系中能唯一地标识一个元组的属性组，简单情况下只有一个属性
- **全码（all-key）**：关系模式的所有属性组是这个关系模式的候选码，为极端情况
- **主码（primary key）**：若一个关系有多个候选码，则选定其中一个为主码
- **主属性（primary attribute）**：获选码中的各个属性
- **非主属性/非码属性**：不属于候选码的属性

**笛卡尔积本身没有实际语义，其某个真子集才有实际含义**

- 在笛卡尔积的示例中的表没有实际语义，因为学院中一个专业可有多个导师，而一个导师只在一个专业带多名研究生，学习一个专业。
- 所以该表的一个真子集才有实际含义，用于表示导师与研究生之间的关系，令关系名为SAP。
- 假如：李勇和刘晨是计算机专业张清玫老师的研究生；王敏是信息专业刘逸老师的研究生。
- 则SAP(SUPERVISOR，SPECIALITY，POSTGRADUATE) 表示为

  | SUPERVISOR | SPECIALITY | POSTGRADUATE |
  | ---------- | ---------- | ------------ |
  | 张清玫     | 计算机专业 | 李勇         |
  | 张清玫     | 计算机专业 | 刘晨         |
  | 刘逸       | 信息专业   | 王敏         |
- 假设POSTGRADUATE不会出现重名，则可以令其为主码

**三类关系**：

- 基本关系（基本表或基表）：实际存在的表，是实际存储数据的逻辑表示
- 查询表：查询结果对应的表
- 视图表：由基本表或其他视图表导出的表，是虚表，不对应实际存储的数据

## 关系模式

- 数据库中需要区分型和值，关系模式是型，关系是值
- 关系模式是对关系的描述
  - 元组集合的结构：属性构成、属性来自的域、属性与域之间的映象关系
  - 完整性约束条件
- 关系模式的形式化表示：$R(U, D, DOM,F)$
  - R：关系名
  - U：组成该关系的属性名集合
  - D：U中属性所来自的域
  - DOM：属性向域的映象集合
  - F：属性间数据的依赖关系的集合
- 关系是关系模式在某一时刻的状态或内容。
  - 关系模式是静态的、稳定的
  - 而关系是动态的、随时间不断变化的，因为关系操作在不断地更新着数据库中的数据
  - 例如，学生关系模式在不同的学年，学生关系是不同的。
- 在实际工作中，人们常常把关系模式和关系都笼统地称为关系，这不难从上下文中加以区别，希望读者注意。

# 关系操作

## 基本的关系操作

- 查询（query）
  - 5种基本操作
    - 选择（selection）
    - 投影（projection）
    - 并（union）
    - 差（difference）
    - 笛卡尔积
  - 其他操作，可用基本操作定义和导出
    - 连接（join）
    - 除（divide）
    - 交（intersection）
- 插入（insert）、删除（delete）、修改（update）

关系操作的特点是集合操作方式，即操作的对象和结果都是集合。这种操作方式也称为一次一集合（sct-at-a-time）的方式。相应地，非关系数据模型的数据操作方式则为一次一记录（record-at-a-time）的方式。

## 关系数据库语言的分类

- **关系代数语言**： 用对关系的运算来表达查询要求（代表：ISBL）
- **关系演算语言**：用谓词来表达查询要求
  - **元组关系演算语言**：谓词变元的基本对象是元组变量（代表：APLHA, QUEL）
  - **域关系演算语言**：谓词变元的基本对象是域变量（代表：QBE）
- **具有关系代数和关系演算双重特点的语言**（代表：SQL）

# 关系的完整性

## 实体完整性

实体完整性规则（Entity Integrity）

- 若属性A是基本关系R的主属性，则属性A不能取空值
- 空值就是“不知道”或“不存在”或“无意义”的值

说明：

1. 实体完整性规则是针对基本关系而言的。一个基本表通常对应现实世界的一个实体集。
2. 现实世界中的实体是可区分的，即它们具有某种唯一性标识。
3. 关系模型中以主码作为唯一性标识。
4. 主码中的属性即主属性不能取空值。主属性取空值，就说明存在某个不可标识的实体，即存在不可区分的实体，这与第2点相矛盾，因此这个规则称为实体完整性

## 参照完整性

**关系间的引用**：

- 在关系模型中实体及实体间的联系都是用关系来描述的，自然存在着关系与关系间的引用。
- 例如：
  - 学生实体：学生（学号，姓名，性别，_专业号_，年龄）
  - 专业实体：专业（_专业号_，专业名）
  - 学生关系引用了专业关系的主码“专业号”
  - 学生关系中的“专业号”值必须是确实存在的专业的专业号

**外码（foreign key）**：

- 设$F$是基本关系$R$的一个或一组属性，但不是关系$R$的码。
- 如果$F$与基本关系$S$的主码$K_S$相对应，则称$F$是$R$的外码
- 基本关系$R$称为**参照关系**（Referencing Relation）
- 基本关系$S$称为**被参照关系**（Referenced Relation）或**目标关系**（Target Relation）
- 注意：
  - 关系$R$和$S$不一定是不同的关系
  - 目标关系$S$的主码$K_S$和参照关系的外码$F$必须定义在同一个（或一组）域上，即同一个数据模型
  - 外码并不一定要与相应的主码同名。当外码与相应的主码属于不同关系时，往往取相同的名字，以便于识别

**参照完整性规则**：
若属性（或属性组）$F$是基本关系$R$的外码它与基本关系$S$的主码$K_S$相对应（$R$和$S$可以相同），则对于$R$中每个元组在$F$上的值必须为：

- 或者取空值（$F$的每个属性值均为空值）
- 或者等于$S$中某个元组的主码值

## 用户自定义的完整性

- 针对某一具体关系数据库的约束条件，反映某一具体应用所涉及的数据必须满足的语义要求
- 关系模型应提供定义和检验这类完整性的机制，以便用统一的系统的方法处理它们，而不需由应用程序承担这一功能

# 关系代数

关系代数是一种抽象的查询语言，它用对关系的运算来表达查询

- 运算对象是关系
- 运算结果亦为关系
- 关系代数的运算符有两类：集合运算符和专门的关系运算符
  - 集合运算是从关系的“水平”方向即行的角度进行
  - 专门的关系运算不仅涉及行而且涉及列

**引入记号**：

- $R(A_1, A_2, \dotso, A_n)$
  > 关系模式
- $R$
  > 关系
- $t$
  > 元组
  >$t \in R$
- $t[A_i]$
  >$t$中相应于属性$A_i$的一个分量
- $A$
  > 属性列 / 属性组
  >$A = \{A_{i1}, A_{i2}, \dotso, A_{ik}\}$
  > 一个属性列是分量集合，是$A_1, A_2, \dotso, A_n$的一部分
- $t[A]$
  >$t[A]=(t[A_{i1}], t[A_{i2}], \dotso, t[A_{ik}])$
  > 表示元组$t$在属性列$A$上各个分量的集合
- $\overline{A}$
  >$\{A_1, A_2, \dotso, A_n\} - A$
- $S$
  > 另一个关系
- $\overgroup{t_r \: t_s}$

  > 元组的连接
  >$t_r \in R, t_s \in S$
  > 示例：
  >
  > > 若：$t_{r_1} = \{a_1, b_1, c_1\}, t_{s_1} = \{c_1, d_1\}$
  > > 则：$\overgroup{t_{r_1} \: t_{s_1}} = \{a_1, b_1, c_1, c_1, d_1\}$

- $Z_X$
  > 象集（Images Set）
  > 给定一个关系$R(X, Z)$，$X, Z$为$R$的属性组，则$Z_X = \{t[Z] \: | \: t \in R, \: t[X] = x\}$
  > 表示$R$中属性组$X$上值为$x$时另一个属性组$Z$上的值的集合，即当$X = x$时$Z$的所有取值
  > 示例：
  >
  > > 若：$R$
  > > |X|Z|
  > > |---|---|
  > > |$x_1$|$z_1$|
  > > |$x_1$|$z_2$|
  > > |$x_1$|$z_3$|
  > > |$x_2$|$z_2$|
  > > |$x_2$|$z_3$|
  > > 则：
  > >$x_1$在$R$中的象集$Z_{x_1} = \{z_1, z_2, z_3\}$>>$x_2$在$R$中的象集$Z_{x_2} = \{z_2, z_3\}$

## 传统的集合运算

传统的集合运算术语二目运算，包括并、差、交、笛卡尔积四种

| 运算                          | 运算符   |
| ----------------------------- | -------- |
| 并（union）                   | $\cup$   |
| 差（difference）              | $-$      |
| 交（intersection）            | $\cap$   |
| 笛卡尔积（cartesian product） | $\times$ |

### 并（Union）

$R \cup S = \{t \: | \: t \in R \lor t \in S\}$

> - 要求：具有相同的目$n$（即都有$n$个属性），相应的属性取自同一个域（即数据模型相同）
> - 结果：仍未$n$目关系，由属于关系$R$和$S$的元组共同组成

### 差（Difference）

$R - S = \{t \: | \: t \in R \land t \notin S\}$

> - 要求：具有相同的目$n$（即都有$n$个属性），相应的属性取自同一个域（即数据模型相同）
> - 结果：仍未$n$目关系，由属于关系$R$且不属于$S$的元组组成

### 交（Intersection）

$R \cap S = \{t \: | \: t \in R \land t \in S\}$

> - 要求：具有相同的目$n$（即都有$n$个属性），相应的属性取自同一个域（即数据模型相同）
> - 结果：仍未$n$目关系，由属于关系$R$且属于$S$的元组组成
> - 用差表示：$R \cap S = R - (R - S)$

### 笛卡尔积（Extended Cartesian Product）

$R \times S = \{\overgroup{t_r \: t_s} \: | \: t_r \in R \land t_s \in S\}$

> - 这里的笛卡尔积为**广义笛卡尔积**（extended cartesian product），这里的笛卡尔积为元素的元组，而非域
> - 要求：无要求，即关系$R$和$S$的目可以不相同，且属性也不要求对应。
> - 若：$R$为$m$目关系，拥有$k_1$个元组；$S$为$n$目关系，有$k_2$个元组
> - 结果：为$(m + n)$目关系（前$m$来自$R$的某一个$m$元组，后$n$个来自$S$的某一个$n$元组），拥有$k_1 \times k_2$个元组

**示例**：
- $R$

  | $A$   | $B$   | $C$   |
  | ----- | ----- | ----- |
  | $a_1$ | $b_1$ | $c_1$ |
  | $a_2$ | $b_2$ | $c_2$ |
  | $a_3$ | $b_3$ | $c_3$ |
- $S$

  | $A$   | $B$   |
  | ----- | ----- |
  | $a_4$ | $b_4$ |
  | $a_5$ | $b_5$ |
- $R \times S$

  | $R.A$ | $R.B$ | $R.C$ | $S.A$ | $S.B$ |
  | ----- | ----- | ----- | ----- | ----- |
  | $a_1$ | $b_1$ | $c_1$ | $a_4$ | $b_4$ |
  | $a_1$ | $b_1$ | $c_1$ | $a_5$ | $b_5$ |
  | $a_2$ | $b_2$ | $c_2$ | $a_4$ | $b_4$ |
  | $a_2$ | $b_2$ | $c_2$ | $a_5$ | $b_5$ |
  | $a_3$ | $b_3$ | $c_3$ | $a_4$ | $b_4$ |
  | $a_3$ | $b_3$ | $c_3$ | $a_5$ | $b_5$ |

## 专门的关系运算

| 运算               | 运算符   |
| ------------------ | -------- |
| 选择（selection）  | σ |
| 投影（projection） | π    |
| 连接（join）       | $\Join$  |
| 除（division）     | $\div$   |

### 选择（Selection）

$\sigma_F(R) = \{t \: | \: t \in R \land F(t) = true\}$

> - 选择又称为限制（Restriction）
> - 含义：在关系$R$中选择满足给定条件的各个元组
> - $F$：选择条件，是一个逻辑表达式，取值为`true(真)`或`false（假）`。基本形式为：XθY，θ表示比较运算符，它可以是`>`, `>=`, `<`, `<=`, `=`或 `<>`

**示例**：
- $Student$

  | 学号Sno  | 姓名Sname | 性别Ssex | 年龄Sage | 所在系Sdept |
  | --------- | ---------- | --------- | --------- | ------------ |
  | 201215121 | 李勇       | 男        | 20        | CS           |
  | 201215122 | 刘晨       | 女        | 19        | CS           |
  | 201215123 | 王敏       | 女        | 18        | MA           |
  | 201215125 | 张立       | 男        | 19        | IS           |
- $\sigma_{Sdept = 'IS'}(Student)$

  | 学号Sno  | 姓名Sname | 性别Ssex | 年龄Sage | 所在系Sdept |
  | --------- | ---------- | --------- | --------- | ------------ |
  | 201215125 | 张立       | 男        | 19        | IS           |
- $\sigma_{Sage < 20}(Student)$

  | 学号Sno  | 姓名Sname | 性别Ssex | 年龄Sage | 所在系Sdept |
  | --------- | ---------- | --------- | --------- | ------------ |
  | 201215122 | 刘晨       | 女        | 19        | CS           |
  | 201215123 | 王敏       | 女        | 18        | MA           |
  | 201215125 | 张立       | 男        | 19        | IS           |

### 投影（Projection）

$\pi_{A}(R) = \{t[A]  \: | \:  t \in R\}$

> - 从$R$中选择出若干属性列（$t[A]$）组成新的关系
> - 投影操作主要是从列的角度进行运算
> - 投影之后不仅取消了原关系中的某些列，而且还可能取消某些元组（避免重复行）

**示例**：
- $\pi_{Sname, Sdept}(Student)$

  | Sname | Sdept |
  | ----- | ----- |
  | 李勇  | CS    |
  | 刘晨  | CS    |
  | 王敏  | MA    |
  | 张立  | IS    |

### 连接（Join）

$R {\Join \atop {A \: \theta \: B}} S = \{\overgroup{t_r \: t_s} \: | \: t_r \in R \land t_s \in S \land t_r[A] \: \theta \: t_s[B]\}$

> - 记号：
>   - $A$和$B$：分别为$R$和$S$上度数相等且可比的属性组
>   - $θ$：比较运算符
> - 含义：从两个关系的笛卡尔积中选取属性间满足一定条件的元组
> - 连接运算从$R$和$S$的广义笛卡尔积$R \times S$中选取$R$关系在$A$属性组上的值与$S$关系在$B$属性组上的值满足比较关系$θ$的元组

#### 等值连接（Equijoin）

$R {\Join \atop \ {A = B}} S = \{\overgroup{t_r \: t_s} \: | \: t_r \in R \land t_s \in S \land t_r[A] = t_s[B]\}$

> - $θ$为`＝`的连接运算称为等值连接（equijoin）
> - 从关系$R$与$S$的广义笛卡尔积中选取$A$、$B$属性值相等的那些元组，即等值连接为

**示例**：
- $R$

  | $\bold{A}$ | $\bold{B}$ | $\bold{C}$ |
  | ---------- | ---------- | ---------- |
  | $a_1$      | $b_1$      | $5$        |
  | $a_1$      | $b_2$      | $6$        |
  | $a_2$      | $b_3$      | $8$        |
  | $a_2$      | $b_4$      | $12$       |
- $S$

  | $\bold{B}$ | $\bold{E}$ |
  | ---------- | ---------- |
  | $b_1$      | $3$        |
  | $b_2$      | $7$        |
  | $b_3$      | $10$       |
  | $b_3$      | $2$        |
  | $b_2$      | $2$        |
- $R {\Join \atop \ {R.B = S.B}} S$

  | $\bold{A}$ | $\bold{R.B}$ | $\bold{C}$ | $\bold{S.B}$ | $\bold{E}$ |
  | ---------- | ------------ | ---------- | ------------ | ---------- |
  | $a_1$      | $b_1$        | $5$        | $b_1$        | $3$        |
  | $a_1$      | $b_2$        | $6$        | $b_2$        | $7$        |
  | $a_2$      | $b_3$        | $8$        | $b_3$        | $10$       |
  | $a_2$      | $b_3$        | $8$        | $b_3$        | $2$        |



#### 自然连接（Natural Join）

$R \Join S = \{\overgroup{t_r \: t_s}[U - B] \: | \: t_r \in R \land t_s \in S \land t_r[A] \: = \: t_s[B]\}$

> - 记号：
>   - $B$：关系$R$和$S$共有的属性组
>   - $U$：关系$R$和$S$所有的属性组（包括共有的属性组）
> - 自然连接（natural join）是一种特殊的等值连接
>   - 两个关系中进行比较的分量必须是相同的属性组
>   - 在结果中把重复的属性列去掉

**示例**：
- $R \Join S$：在等值连接的结果上去除重复的列

  | $\bold{A}$ | $\bold{B}$ | $\bold{C}$ | $\bold{E}$ |
  | ---------- | ---------- | ---------- | ---------- |
  | $a_1$      | $b_1$      | $5$        | $3$        |
  | $a_1$      | $b_2$      | $6$        | $7$        |
  | $a_2$      | $b_3$      | $8$        | $10$       |
  | $a_2$      | $b_3$      | $8$        | $2$        |

##### 悬浮元组

自然连接（$R \Join S$）时，关系$R$中某些元组有可能在$S$中不存在公共属性上值相等的元组（$t_r[A]$存在，但$t_r[A] = t_s[B]$不存在），从而造成$R$中这些元组在操作时被舍弃了。同样，$S$中某些元组也可能被舍弃。这些被舍弃的元组称为悬浮元组（dangling tuple）

##### 外连接（Outer Join）

outer join
保留$R$和$S$的悬浮元组，在相应属性中填充`NULL`值

**示例**：
- $R \Join S$：在自然连接的结果上添加$R$和$S$的悬浮元组

  | $\bold{A}$ | $\bold{B}$ | $\bold{C}$ | $\bold{E}$ |
  | ---------- | ---------- | ---------- | ---------- |
  | $a_1$      | $b_1$      | $5$        | $3$        |
  | $a_1$      | $b_2$      | $6$        | $7$        |
  | $a_2$      | $b_3$      | $8$        | $10$       |
  | $a_2$      | $b_3$      | $8$        | $2$        |
  | $a_2$      | $b_4$      | $12$       | $NULL$     |
  | $NULL$     | $b_5$      | $NULL$     | $2$        |

##### 左外连接（Left Join）

left outer join或left join
只保留$R$的悬浮元组，在$S$相应属性中填充`NULL`值

**示例**：
- $R \Join S$：在自然连接的结果上添加$R$的悬浮元组

  | $\bold{A}$ | $\bold{B}$ | $\bold{C}$ | $\bold{E}$ |
  | ---------- | ---------- | ---------- | ---------- |
  | $a_1$      | $b_1$      | $5$        | $3$        |
  | $a_1$      | $b_2$      | $6$        | $7$        |
  | $a_2$      | $b_3$      | $8$        | $10$       |
  | $a_2$      | $b_3$      | $8$        | $2$        |
  | $a_2$      | $b_4$      | $12$       | $NULL$     |

##### 右外连接（Right Join）

right outer join或right join
只保留$S$的悬浮元组，在$R$相应属性中填充`NULL`值

**示例**：
- $R \Join S$：在自然连接的结果上添加$S$的悬浮元组

  | $\bold{A}$ | $\bold{B}$ | $\bold{C}$ | $\bold{E}$ |
  | ---------- | ---------- | ---------- | ---------- |
  | $a_1$      | $b_1$      | $5$        | $3$        |
  | $a_1$      | $b_2$      | $6$        | $7$        |
  | $a_2$      | $b_3$      | $8$        | $10$       |
  | $a_2$      | $b_3$      | $8$        | $2$        |
  | $NULL$     | $b_5$      | $NULL$     | $2$        |

### 除（Division）

$R \div S = \{t_r[X] \: | \: t_r \in R \land \pi_Y(S) \subseteq Y_X\}$

> - 给定关系$R(X, Y)$和$S(Y, Z)$。$X$、$Y$、$Z$为属性组，其中$Y$表示共有属性组
>   - $R$中的$Y$与$S$中的$Y$可以有不同的属性名，但必须出自相同的域集
>   - $R$与$S$的除运算得到一个新的关系$P(X)$
> - $P$是$R$中满足下列条件的元组在$X$属性列上的投影：
>   - 当$X = x$时，$x$在$R$中的象集$Y_x$在$S$的投影$\pi_Y(S)$中存在，即$Y_x$和$\pi_Y(S)$的交集不为空
>   - 换一种表达方法：$R \div S = \{t_r[X] \: | \: t_r \in R \land \pi_Y(S) \cap Y_X \ne \empty\}$

**示例**：
- $R$

  | $\bold{A}$ | $\bold{B}$ | $\bold{C}$ |
  | ---------- | ---------- | ---------- |
  | $a_1$      | $b_1$      | $c_2$      |
  | $a_2$      | $b_3$      | $c_7$      |
  | $a_3$      | $b_4$      | $c_6$      |
  | $a_1$      | $b_2$      | $c_3$      |
  | $a_4$      | $b_6$      | $c_6$      |
  | $a_2$      | $b_2$      | $c_3$      |
  | $a_1$      | $b_2$      | $c_1$      |
- $S$

  | $\bold{B}$ | $\bold{C}$ | $\bold{D}$ |
  | ---------- | ---------- | ---------- |
  | $b_1$      | $c_2$      | $d_1$      |
  | $b_2$      | $c_1$      | $d_1$      |
  | $b_2$      | $c_3$      | $d_2$      |
- $A$在$R$中的象集$T_A$（$\: T = \{B, C\}$）

  | $\bold{A}$ | $\bold{T_A}$                             |
  | ---------- | ---------------------------------------- |
  | $a_1$      | $\{(b_1, c_2), (b_2, c_3), (b_2, c_1)\}$ |
  | $a_2$      | $\{(b_3, c_7), (b_2, c_3)\}$             |
  | $a_3$      | $\{(b_4, c_6)\}$                         |
  | $a_4$      | $\{(b_6, c_6)\}$                         |
- $S$在$B, C$上的投影$\pi_{B, C}(S)$

  |$\bold{\pi_{B, C}(S)}$|
  |---|
  |$(b_1, c_2)$|
  |$(b_2, c_1)$|
  |$(b_2, c_3)$|
- $T_A$和$\pi_{B, C}(S)$的交集

  | $\bold{A}$ | $\bold{T_A \cap \pi_{B, C}(S)}$ |
  | ---------- | ------------------------------- |
  | $a_1$      | $\{(b_1, c_2)\}$                |
  | $a_2$      | $\empty$                        |
  | $a_3$      | $\empty$                        |
  | $a_4$      | $\empty$                        |
- 所以$R \div S$的结果为

  |$\bold{R \div S}$|
  |---|
  |$a_1$|

# 关系演算

## 元组关系演变运算语言ALPHA

**主要语句**：
- GET
- PUT
- HOLD
- UPDATE
- DELETE
- DROP

**语句的基本格式**：
- `操作语句 工作空间名 (表达式)：操作条件`
- 例如：
    - 查询1个所在系为IS的学生的Sno和Sname
    - `GET W (1)(Student.Sno, Student.Sname): Student.Sdept = 'IS'`


## 元组关系演变运算

## 域关系演变运算语言QBE