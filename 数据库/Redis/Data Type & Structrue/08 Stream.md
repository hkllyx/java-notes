- [概述](#概述)
- [相关命令](#相关命令)
  - [XACK](#xack)
  - [XADD](#xadd)
  - [XCLAIM](#xclaim)
  - [XDEL](#xdel)
  - [XGROUP](#xgroup)
    - [XGROUP CREATE](#xgroup-create)
    - [XGROUP DESTROY](#xgroup-destroy)
    - [XGROUP DELCONSUMER](#xgroup-delconsumer)
    - [XGROUP SETID](#xgroup-setid)
  - [XINFO](#xinfo)
    - [XINFO STREAM](#xinfo-stream)
    - [XINFO GROUPS](#xinfo-groups)
    - [XINFO CONSUMERS](#xinfo-consumers)
  - [XLEN](#xlen)
  - [XPENDING](#xpending)
  - [XRANGE, XREVRANGE](#xrange-xrevrange)
  - [XREAD, XREADGROUP](#xread-xreadgroup)
  - [XTRIM](#xtrim)

# 概述

参见 [Stream](../Advance/Stream.md) 文档。

# 相关命令

## XACK

```
XACK key group ID [ID ...]
```
- 用于从stream的消费者组的待处理条目列表（pending entries list, PEL）中删除一条或多条消息。
- 当一条消息交付到某个消费者时，它将被存储在PEL中等待处理，这通常在作为调用`XREADGROUP`命令的副作用时出现，或者一个消费者通过调用`XCLAIM`命令接管消息的时候。
- 待处理消息被交付到某些消费者，但是服务器尚不确定它是否至少被处理了一次。因此对新调用`XREADGROUP`来获取消费者的消息历史记录（比如用0作为ID）将返回此类消息。
- 类似地，待处理的消息将由检查PEL的`XPENDING`命令列出。
- 一旦消费者成功地处理完一条消息，它应该调用 `XACK`，这样这个消息就不会被再次处理，且作为一个副作用，关于此消息的PEL条目也会被清除，从Redis服务器释放内存。
- 该命令返回成功确认的消息数。某些消息ID可能不再是PEL的一部分（例如因为它们已经被确认），而且`XACK`不会把他们算到成功确认的数量中。

## XADD

```
XADD key ID field string [field string ...]
```
- 将指定的Stream Entry追加到指定key的Stream中。如果key不存在，作为运行这个命令的副作用，将使用Stream Entry自动创建key。
- 一个Entry是由一组键值对组成的，它基本上是一个小的字典。键值对以用户给定的顺序存储，并且读取Stream的命令（如`XRANGE`或者`XREAD`）可以保证按照通过 `XADD`添加的顺序返回。
- `XADD` 是唯一可以向Stream添加数据的Redis命令，但是还有其他命令，例如`XDEL`和 `XTRIM`，他们能够从Stream中删除数据。
- Stream Entry的ID标识Stream内的给定Entry。如果指定的ID参数是字符 "*"（星号ASCII字符），`XADD` 命令会自动生成一个唯一的ID。但是，也可以指定一个良好格式的ID，以便新的条目以指定的ID准确存储，虽然仅在极少数情况下有用。
- ID是由 "-" 隔开的两个数字组成的，例如，1526919030474-55
    - 两个部分数字都是64位的，当自动生成ID时，第一部分是生成ID的Redis实例的毫秒格式的Unix时间。
    - 第二部分只是一个序列号，以及是用来区分同一毫秒内生成的ID的。
- ID保证始终是递增的：如果比较刚插入的条目的ID，它将大于其他任何过去的ID，因此Entry在Stream中是完全排序的。为了保证这个特性，如果Stream中当前最大的ID的时间大于实例的当前本地时间，将会使用前者，并将ID的序列部分递增。例如，本地始终回调了，或者在故障转移之后新主机具有不同的绝对时间，则可能发生这种情况。
- 当用户为`XADD`命令指定显式ID时，最小有效的ID是0-1，并且用户必须指定一个比当前Stream中的任何ID都要大的ID，否则命令将失败。通常使用特定ID仅在您有另一个系统生成唯一ID（例如SQL表），并且您确实希望Redis Stream ID与该另一个系统的ID匹配时才有用。

```
XADD key MAXLEN [~] count field string [field string ...]
```
- 上限Stream：可以使用MAXLEN选项来限制Stream中的最大元素数量。
- 与使用`XADD`添加Entry相比较，使用MAXLEN修整会很昂贵：Stream由宏节点表示为基数树，以便非常节省内存。改变由几十个元素组成的单个宏节点不是最佳的。因此可以使用以下特殊形式提供命令：
    ```
    XADD mystream MAXLEN~1000 * ... entry fields here ...
    ```
    - 在选项MAXLEN和实际计数中间的参数 "~" 的意思是：用户不是真的需要精确的1000个项目。它可以多几十个条目，但决不能少于1000个。通过使用这个参数，仅当我们移除整个节点的时候才执行修整。这使得命令更高效，而且这也是我们通常想要的。

## XCLAIM

```
XCLAIM key group consumer min-idle-time ID [ID ...]
    [IDLE ms] [TIME ms-unix-time] [RETRYCOUNT count] [FORCE] [JUSTID]
```
- 在流的消费者组上下文中，此命令改变待处理消息的所有权，因此新的所有者是在命令参数中指定的消费者。通常是这样的：
    1. 假设有一个具有关联消费者组的流。
    2. 某个消费者A在消费者组的上下文中通过`XREADGROUP`从流中读取一条消息。
    3. 作为读取消息的副作用，消费者组的PEL中创建了一个待处理消息条目：这意味着这条消息已传递给给定的消费者，但是尚未通过`XACK`确认。
    4. 突然这个消费者出现故障，且永远无法恢复。
    5. 其他消费者可以使用`XPENDING`检查已经过时很长时间的待处理消息列表，为了继续处理这些消息，他们使用`XCLAIM`来获得消息的所有权，并继续处理。
- Stream介绍文档中清楚的解释了这种动态。
- 请注意，消息只有在其空闲时间大于我们通过`XCLAIM`指定的空闲时间的时才会被认领。因为作为一个副作用，`XCLAIM` 也会重置消息的空闲时间（因为这是处理消息的一次新尝试），两个试图同时认领消息的消费者将永远不会成功：只有一个消费者能成功认领消息。这避免了我们用微不足道的方式多次处理给定的消息（虽然一般情况下无法完全避免多次处理）。
- 此外，作为副作用，`XCLAIM` 会增加消息的尝试交付次数。通过这种方式，由于某些原因而无法处理的消息（例如因为消费者在尝试处理期间崩溃），将开始具有更大的计数器，并可以在系统内部被检测到。
- 命令选项：该命令有多个选项，但是大部分主要用于内部使用，以便将`XCLAIM`或其他命令的结果传递到AOF文件，以及传递相同的结果到从节点，并且不太可能对普通用户有用：

    | 选项                | 说明                                                                                                                                                                                                                        |
    | ------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
    | IDLE <ms>           | 设置消息的空闲时间（自最后一次交付到目前的时间）。省缺值为0，即时间计数被重置，因为消息现在有新的所有者来尝试处理它                                                                                                        |
    | TIME <ms-unix-time> | 这个命令与IDLE相同，但它不是设置相对的毫秒数，而是将空闲时间设置为一个指定的Unix时间（以毫秒为单位）。这对于重写生成`XCLAIM`命令的AOF文件很有用                                                                     |
    | RETRYCOUNT <count>  | 将重试计数器设置为指定的值。这个计数器在每一次消息被交付的时候递增。通常，`XCLAIM` 不会更改这个计数器，它只在调用`XPENDING`命令时提供给客户端：这样客户端可以检测到异常，例如在大量传递尝试后由于某种原因从未处理过的消息 |
    | FORCE               | 在PEL中创建待处理消息条目，即使某些指定的ID尚未在分配给不同客户端的PEL中。但是消息必须存在于流中，否则不存在的消息ID将会被忽略                                                                                      |
    | JUSTID              | 只返回成功认领的消息ID数组，不返回实际的消息                                                                                                                                                                              |

## XDEL

```
XDEL key ID [ID ...]
```
- 从指定流中移除指定的条目，并返回成功删除的条目的数量，在传递的ID不存在的情况下，返回的数量可能与传递的ID数量不同。
- 通常，你可能将Redis流想象为一个仅附加的数据结构，但是Redis流是存在于内存中的，所以我们也可以删除条目。这也许会有用，例如，为了遵守特定的隐私策略。
- 理解删除条目的底层细节
    - Redis流以一种使其内存高效的方式表示：使用基数树来索引包含线性数十个Stream条目的宏节点。通常，当你从Stream中删除一个条目的时候，条目并没有真正被驱逐，只是被标记为删除。
    - 最终，如果宏节点中的所有条目都被标记为删除，则会销毁整个节点，并回收内存。这意味着如果你从Stream里删除大量的条目，比如超过50% 的条目，则每一个条目的内存占用可能会增加，因为Stream将会开始变得碎片化。然而，流的表现将保持不变。
    - 在Redis未来的版本中，当一个宏节点内删除条目达到一定数量的时候，我们有可能会触发节点垃圾回收机制。目前，根据我们对这种数据结构的预期用途，还不太适合增加这样的复杂度。

## XGROUP

该命令用于管理Stream数据结构关联的消费者组。使用`XGROUP`可以完成一下四件事。

### XGROUP CREATE

```
XGROUP CREATE key group-name id
```
- 创建与流关联的新消费者组。
- 最后一个参数id是要考虑已传递的流中最后一项的ID。
- 使用 "$" 表示流中最后一项的ID，在这种情况下，从该消费者组获取数据的消费者只能看到到达流的新元素。
- 如果指定的消费者组已经存在，则该命令将返回BUSYGROUP错误。否则将执行该操作并返回OK。
- 可以为给定的流关联无限多的消费者组，没有硬性限制。

### XGROUP DESTROY

```
XGROUP DESTROY key group-name
```
- 即使存在活动的消费者和待处理消息，消费者组也将被销毁，因此请确保仅在真正需要时才调用此命令。

### XGROUP DELCONSUMER

```
XGROUP DELCONSUMER key group-name consumer-name
```
- 从消费者组中移除指定的消费者。
- 每当某个命令提到新的消费者名称时，就会自动创建消费者组中的消费者。
- 但有时候删除旧的消费者可能会有用，因为他们已经不再使用。
- 命令返回消费者在被删除之前所拥有的待处理消息数量。

### XGROUP SETID

```
XGROUP SETID key id
```
- 设置将消费者组的最后交付ID，即下一条要传递的消息。
- 通常情况下，在消费者创建时设置下一个ID（作为`XGROUP CREATE`的最后一个参数）。但是使用这种形式，可以在以后修改下一个ID，而无需再次删除和创建使用者组。
- 例如，如果你希望消费者组中的消费者重新处理流中的所有消息，你可能希望将其下一个ID设置为0。
- 可以使用 "$" 字符表示最后一项的ID

## XINFO

这是一个内省命令，用于检索关于流和关联的消费者组的不同的信息。有三种可能的形式：

### XINFO STREAM

```
XINFO STREAM key
```
- 返回有关存储在特定键的流的一般信息。
- 报告的信息：
    - 流的元素的数量
    - 有关表示流的基数树的详细信息（主要用于优化和调试任务）
    - 与流关联的消费者组的数量
    - 最后生成的ID（某些条目被删除时，此ID可能与最后一个条目的ID不同）
    - 最后显示了流中完整的第一个和最后一个条目，以便了解流的内容是什么

### XINFO GROUPS

```
XINFO GROUPS key
```
- 只获得与流关联的所有消费者组的输出。
- 对每一个列出的消费者组，该命令还显示该组中已知的消费者数量，以及该组中的待处理消息（已传递但尚未确认）数量。

### XINFO CONSUMERS

```
XINFO CONSUMERS key group-name
```
- 取得指定消费者组中的消费者列表。
- 这个消费者的空闲毫秒时间（最后一个字段）以及消费者名称和待处理消息数量。

请注意，你不应该依赖字段的确切位置，也不应该依赖字段的数量，因为将来可能会增加新的字段。因此，表现良好的客户端应该获取整个列表，并将其报告给用户，例如，作为字典数据结构。低级客户端（例如C客户端，其中项目可能以线性数组报告）应该注明顺序是不确定的。

## XLEN

```
XLEN key
```
- 返回流中的条目数。如果指定的key不存在，则此命令返回0，就好像该流为空。但是请注意，与其他的Redis类型不同，零长度流是可能的，所以你应该调用`TYPE`或者`EXISTS`来检查一个key是否存在。
- 一旦内部没有任何的条目（例如调用`XDEL`后），流不会被自动删除，因为可能还存在与其相关联的消费者组。

## XPENDING

```
XPENDING key group [start end count] [consumer]
```
- 通过消费者组从流中获取数据，而不是确认这些数据，具有创建待处理条目的效果。这在`XREADGROUP`命令中已有详尽的说明，在我们的Redis Streams介绍中更好。`XACK` 命令会立即从待处理条目列表（PEL）中移除待处理条目，因为一旦消息被成功处理，消费者组就不再需要跟踪它并记住消息的当前所有者。
- `XPENDING` 命令是检查待处理消息列表的接口，因此它是一个非常重要的命令，用于观察和了解消费者组正在发生的事情：哪些客户端是活跃的，哪些消息在等待消费，或者查看是否有空闲的消息。此外，该命令与`XCLAIM`一起使用，用于实现长时间故障的消费者的恢复，因此不处理某些消息：不同的消费者可以认领该消息并继续处理。这在Redis Streams介绍和`XCLAIM`命令页面中有更好的解释，这里不再介绍。

## XRANGE, XREVRANGE

```
XRANGE key start end [COUNT count]
```
- 返回流中满足给定ID范围的条目。范围由最小和最大ID指定。所有ID在指定的两个ID之间或与其中一个ID相等（闭合区间）的条目将会被返回。
- `XRANGE` 命令有许多用途：
    - 返回特定时间范围的项目。这是可能的，因为流的ID与时间相关。
    - 增量迭代流，每次迭代只返回几个项目。但它在语义上比`SCAN`函数族强大很多。
    - 从流中获取单个条目，提供要获取两次的条目的ID：作为查询间隔的开始和结束。
- 特殊ID："-" 和 "+" 分别表示流中可能的最小ID和最大ID。

```
XREVRANGE key end start [COUNT count]
```
- 此命令与`XRANGE`完全相同，但显著的区别是以相反的顺序返回条目，并以相反的顺序获取开始~结束参数。

## XREAD, XREADGROUP

```
XREAD [COUNT count] [BLOCK milliseconds]
    STREAMS key [key ...] ID [ID ...]
```
- 从一个或者多个流中读取数据，仅返回ID大于调用者报告的最后接收ID的条目。
- 此命令有一个BLOCK选项，用于等待可用的项目，类似于`BRPOP`或者`BZPOPMIN`等等。
- 如果未提供BLOCK选项，此命令是同步的，并可以认为与`XRANGE`有些相关：它将会返回流中的一系列项目，但与`XRANGE`相比它有两个基本差异（如果我们只考虑同步使用）：
    - 如果我们想要从多个键同时读取，则可以使用多个流调用此命令。这是`XREAD`的一个关键特性，因为特别是在使用`BLOCK`进行阻塞时，能够通过单个连接监听多个键是一个至关重要的特性。
    - `XRANGE` 返回一组ID中的项目，`XREAD` 更适合用于从第一个条目（比我们到目前为止看到的任何其他条目都要大）开始使用流。因此，对于每个流我们传递给`XREAD`的是从该流接收的最后一个条目的ID。
    - 例如，如果我有两个流mystream和writers，并且我希望同时从这两个流中读取数据（从它们的第一个元素开始），我可以像下面这样调用XREAD：
        ```
        XREAD COUNT 2 STREAMS mystream writers 0-0 0-0
        ```
        请注意：我们在例子中使用了COUNT选项，因此对于每一个流，调用将返回每个流最多两个元素。
- STREAMS选项是强制的，并且必须是最后一个选项。
- 使用不完整的ID是有效的，就像它对`XRANGE`一样有效。但是这里ID的序列号部分，如果缺少，将总是被解释为0，所以以下命令等效：
    ```
    XREAD COUNT 2 STREAMS mystream writers 0 0
    XREAD COUNT 2 STREAMS mystream writers 0-0 0-0
    ```
- 特殊的ID "$"：有时阻塞我们只希望接收从我们阻塞的那一刻开始通过XADD添加到流的条目。在这种情况下，我们对已经添加条目的历史不感兴趣。
- 详见 [XREAD](http://redis.cn/commands/xread.html)

```
XREADGROUP GROUP group consumer [COUNT count]
    [BLOCK milliseconds] STREAMS key [key ...] ID [ID ...]
```
- `XREADGROUP` 命令是`XREAD`命令的特殊版本，支持消费者组。

## XTRIM

```
XTRIM key MAXLEN [~] count
```
- 将流裁剪为指定数量的项目，如有需要，将驱逐旧的项目（ID较小的项目）。
- 此命令被设想为接受多种修整策略，但目前只实现了一种，即`MAXLEN`，并且与 `XADD`中的`MAXLEN`选项完全相同。