- [HyperLogLog](#hyperloglog)
- [基数计数](#基数计数)
- [基数计数方法](#基数计数方法)
- [概率算法](#概率算法)
- [HLL在Redis中的应用（命令）](#hll在redis中的应用命令)
    - [PFADD](#pfadd)
    - [PFCOUNT](#pfcount)
    - [PFMERGE](#pfmerge)

# HyperLogLog

- Redis HyperLogLog是用来做基数统计的算法，HyperLogLog的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定 的、并且是很小的。
- 在Redis里面，每个HyperLogLog键只需要花费12 KB内存，就可以计算接近2^64个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。
- 但是，因为HyperLogLog只会根据输入元素来计算基数，而不会储存输入元素本身，所以HyperLogLog不能像集合那样，返回输入的各个元素。

# 基数计数

- **基数计数** (cardinality counting) 通常用来统计一个集合中不重复的元素个数，例如统计某个网站的UV，或者用户搜索网站的关键词数量。
- 数据分析、网络监控及数据库优化等领域都会涉及到基数计数的需求。
- 要实现基数计数，最简单的做法是：
    - 记录集合中所有不重复的元素集合$S_u$，当新来一个元素$x_i$
    - 若$S_u$中不包含元素$x_i$，则将$x_i$加入$S_u$
    - 否则不加入
    - 计数值就是$S_u$的元素数量。
- 这种做法存在两个问题：
    - 当统计的数据量变大时，相应的存储内存也会线性增长
    - 当集合$S_u$变大，判断其是否包含新加入元素$x_i$的成本变大
- 大数据量背景下，要实现基数计数，首先需要确定存储统计数据的方案，以及如何根据存储的数据计算基数值；
- 另外还有一些场景下需要融合多个独立统计的基数值，例如对一个网站分别统计了三天的UV，现在需要知道这三天的UV总量是多少，怎么融合多个统计值。

# 基数计数方法

- B-Tree
   > - B树最大的优势是插入和查找效率很高，如果用B树存储要统计的数据，可以快速判断新来的数据是否已经存在，并快速将元素插入B树。
   > - 要计算基数值，只需要计算B树的节点个数。
   > - 将B树结构维护到内存中，可以快速统计和计算，但依然存在问题，B树结构只是加快了查找和插入效率，并没有节省存储内存。
   > - 例如要同时统计几万个链接的UV，每个链接的访问量都很大，如果把这些数据都维护到内存中，实在是够呛。
- Bitmap
   > - bitmap可以理解为通过一个bit数组来存储特定数据的一种数据结构，每一个bit位都能独立包含信息，bit是数据的最小存储单位，因此能大量节省空间，也可以将整个bit数据一次性load到内存计算。

# 概率算法

- 实际上目前还没有发现更好的在大数据场景中准确计算基数的高效算法，因此在不追求绝对准确的情况下，使用概率算法算是一个不错的解决方案。
- 概率算法不直接存储数据集合本身，通过一定的概率统计方法预估基数值，这种方法可以大大节省内存，同时保证误差控制在一定范围内。目前用于基数计数的概率算法包括:
    - Linear Counting(LC)
        > 早期的基数估计算法，LC在空间复杂度方面并不算优秀，实际上LC的空间复杂度与上文中简单bitmap方法是一样的（但是有个常数项级别的降低），都是$O(N_{max})$
    - LogLog Counting(LLC)
        > 相比于LC更加节省内存，空间复杂度只有$O(log_2(log_2(N_{max})))$
    - HyperLogLog Counting(HLL)
        > 基于LLC的优化和改进，在同样空间复杂度情况下，能够比LLC的基数估计误差更小

# HLL在Redis中的应用（命令）

## PFADD

```
PFADD key element [element ...]
```
- 将element存储到key的HyperLogLog结构中。
- 这个命令的一个副作用是它可能会更改这个HyperLogLog的内部来反映在每添加一个唯一的对象时估计的基数 (集合的基数)。
- 如果一个HyperLogLog的估计的近似基数在执行命令过程中发了变化，`PFADD` 返回1，否则返回0。
- 如果指定的key不存在，这个命令会自动创建一个空的HyperLogLog结构（指定长度和编码的字符串）。
- 如果在调用该命令时仅提供key而不指定element也是可以的，如果这个key存在，则不会有任何操作，如果不存在，则会创建一个数据结构（返回1）

## PFCOUNT

```
PFCOUNT key [key ...]
```
- 当参数为一个key时，返回存储在HyperLogLog结构体的该变量的近似基数，如果该变量不存在，则返回0。
- 当参数为多个key时，返回这些HyperLogLog并集的近似基数，这个值是将所给定的所有key的HyperLoglog结构合并到一个临时的HyperLogLog结构中计算而得到的。
- HyperLogLog可以使用固定且很少的内存（每个HyperLogLog结构需要12K字节再加上key本身的几个字节）来存储集合的唯一元素。
- 返回的可见集合基数并不是精确值，而是一个带有0.81% 标准错误（standard error）的近似值。
- 例如为了记录一天会执行多少次各不相同的搜索查询，一个程序可以在每次执行搜索查询时调用一次`PFADD`，并通过调用 `PFCOUNT`命令来获取这个记录的近似结果。
- 注意：这个命令的一个副作用是可能会导致HyperLogLog内部被更改，出于缓存的目的，它会用8字节的来记录最近一次计算得到基数，**所以`PFCOUNT`命令在技术上是个写命令**。

## PFMERGE

```
PFMERGE destkey sourcekey [sourcekey ...]
```
- 将多个HyperLogLog合并（merge）为一个HyperLogLog，合并后的HyperLogLog的基数接近于所有输入HyperLogLog的可见集合（observed set）的并集。
- 合并得出的HyperLogLog会被储存在目标变量（第一个参数）里面，如果该键并不存在，那么命令在执行之前，会先为该键创建一个空的。