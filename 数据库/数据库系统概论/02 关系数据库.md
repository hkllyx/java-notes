- [关系数据结构及形式化定义](#关系数据结构及形式化定义)
  - [关系](#关系)
    - [域（domain）](#域domain)
    - [笛卡尔积（cartesian product）](#笛卡尔积cartesian-product)
    - [关系（relation）](#关系relation)
  - [关系模式](#关系模式)
- [关系操作](#关系操作)
  - [基本的关系操作](#基本的关系操作)
  - [关系数据库语言的分类](#关系数据库语言的分类)
- [关系的完整性](#关系的完整性)
  - [实体完整性](#实体完整性)
  - [参照完整性](#参照完整性)
  - [用户自定义的完整性](#用户自定义的完整性)
- [关系代数](#关系代数)
  - [传统的集合运算](#传统的集合运算)
    - [并（Union）](#并union)
    - [差（Difference）](#差difference)
    - [交（Intersection）](#交intersection)
    - [笛卡尔积（Extended Cartesian Product）](#笛卡尔积extended-cartesian-product)
  - [专门的关系运算](#专门的关系运算)
    - [选择（Selection）](#选择selection)
    - [投影（Projection）](#投影projection)
    - [连接（Join）](#连接join)
      - [等值连接（Equijoin）](#等值连接equijoin)
      - [自然连接（Natural Join）](#自然连接natural-join)
        - [悬浮元组](#悬浮元组)
        - [外连接（Outer Join）](#外连接outer-join)
        - [左外连接（Left Join）](#左外连接left-join)
        - [右外连接（Right Join）](#右外连接right-join)
    - [除（Division）](#除division)
- [关系演算](#关系演算)
  - [元组关系演变运算语言 ALPHA](#元组关系演变运算语言-alpha)
  - [元组关系演变运算](#元组关系演变运算)
  - [域关系演变运算语言 QBE](#域关系演变运算语言-qbe)

# 关系数据结构及形式化定义

## 关系

- 关系模型的数据结构非常简单，只包含单一的数据结构 —— 关系
- 在用户看来，关系模型中数据的逻辑结构是一张扁平的二维表。
- 在关系模型中，现实世界的实体以及实体间的各种联系均用关系来表示。
- 关系模型建立在集合代数的基础上

### 域（domain）

- 是一组具有相同数据类型的值的集合
- 例如：自然数、整数、实数、{男, 女}...

### 笛卡尔积（cartesian product）

笛卡尔积是域上的一种集合运算。
给定一组域 $D_1, D_2, \dotso, D_n$，允许其中某些域是相同的。 该一组域的笛卡尔积为：
$D_1 \times D_2 \times \dotso \times D_n ＝ \{(d_1, d_2, \dotso, d_n) \: | \: d_i \in D_i, \: i ＝ 1, 2, \dotso, n \}$

- **n-元组（n-turple）**：简称元组，笛卡尔积的一个元素 —— $(d_1, d_2, \dotso, d_n)$
- **分量（component）**：笛卡尔积的一个元素的每一个值 —— $d_i$
- **基数（cardinal number）**：一个域允许的不同取值个数，
  - 若 $D_i(i ＝ 1, 2, \dotso, n)$ 为有限集，其基数为 $m_i(i ＝ 1, 2, \dotso, n)$，则$D_1 \times D_2 \times \dotso \times D_n$ 的基数为：
  - $M = \prod_{i = i}^{n}m_i$

**笛卡尔积的表示方法**：

- 笛卡尔积可表示为一张二维表
- 表中的每行对应一个元组
- 表中的每列对应一个域

**示例**：
- $D_1$ = 导师集合 SUPERVISOR = {张清玫，刘逸}
- $D_2$ = 专业集合 SPECIALITY = {计算机专业，信息专业}
- $D_3$ = 研究生集合 POSTGRADUATE = {李勇，刘晨，王敏}
- $D_1 \times D_2 \times D_3 =$ { (张清玫，计算机专业，李勇)，(张清玫，计算机专业，刘晨)，
  $\qquad\qquad\qquad\qquad$(张清玫，计算机专业，王敏)，(张清玫，信息专业，李勇)，
  $\qquad\qquad\qquad\qquad$(张清玫，信息专业，刘晨)，(张清玫，信息专业，王敏)，
  $\qquad\qquad\qquad\qquad$(刘逸，计算机专业，李勇)，(刘逸，计算机专业，刘晨)，
  $\qquad\qquad\qquad\qquad$(刘逸，计算机专业，王敏)，(刘逸，信息专业，李勇)，
  $\qquad\qquad\qquad\qquad$(刘逸，信息专业，刘晨)，(刘逸，信息专业，王敏) }
- $M = 2 \times 2 \times 3 = 12$
- 表格表示：

  | SUPERVISOR | SPECIALITY | POSTGRADUATE |
  | ---------- | ---------- | ------------ |
  | 张清玫     | 计算机专业 | 李勇         |
  | 张清玫     | 计算机专业 | 刘晨         |
  | 张清玫     | 计算机专业 | 王敏         |
  | 张清玫     | 信息专业   | 李勇         |
  | 张清玫     | 信息专业   | 刘晨         |
  | 张清玫     | 信息专业   | 王敏         |
  | 刘逸       | 计算机专业 | 李勇         |
  | 刘逸       | 计算机专业 | 刘晨         |
  | 刘逸       | 计算机专业 | 王敏         |
  | 刘逸       | 信息专业   | 李勇         |
  | 刘逸       | 信息专业   | 刘晨         |
  | 刘逸       | 信息专业   | 王敏         |

### 关系（relation）

笛卡尔积 $D_1 \times D_2 \times \dotso \times D_n$ 的子集，叫作在域 $D_1, D_2, \dotso, D_n$ 上的关系
表示为：$R(D_1, D_2, \dotso, D_n)$

- **元组**：关系中的元素，用 $t$ 表示
- **关系名**：$R$
- **关系的目或度（Degree）**：$n$
  - $n = 1$ 时，该关系称为单元 / 一元关系（unary relation）
  - $n = 2$ 时，该关系称为二元关系（binary relation）

**关系的表示方法**：

- 笛卡尔积的子集，也是一个二维表
- 表的每行对应一个元组
- 表的每列对应一个域

**属性（attribute）**：关系中不同列可以对应相同的域，为了加以区分，必须对每列起一个名字，称为属性。$n$ 目关系必有 $n$ 个属性。

**码（key）**：

- **候选码（candidate key）**：关系中能唯一地标识一个元组的属性组，简单情况下只有一个属性
- **全码（all-key）**：关系模式的所有属性组是这个关系模式的候选码，为极端情况
- **主码（primary key）**：若一个关系有多个候选码，则选定其中一个为主码
- **主属性（primary attribute）**：获选码中的各个属性
- **非主属性/非码属性**：不属于候选码的属性

**笛卡尔积本身没有实际语义，其某个真子集才有实际含义**

- 在笛卡尔积的示例中的表没有实际语义，因为学院中一个专业可有多个导师，而一个导师只在一个专业带多名研究生，学习一个专业。
- 所以该表的一个真子集才有实际含义，用于表示导师与研究生之间的关系，令关系名为 SAP。
- 假如：李勇和刘晨是计算机专业张清玫老师的研究生；王敏是信息专业刘逸老师的研究生。
- 则 SAP(SUPERVISOR，SPECIALITY，POSTGRADUATE) 表示为

  | SUPERVISOR | SPECIALITY | POSTGRADUATE |
  | ---------- | ---------- | ------------ |
  | 张清玫     | 计算机专业 | 李勇         |
  | 张清玫     | 计算机专业 | 刘晨         |
  | 刘逸       | 信息专业   | 王敏         |
- 假设 POSTGRADUATE 不会出现重名，则可以令其为主码

**三类关系**：

- 基本关系（基本表或基表）：实际存在的表，是实际存储数据的逻辑表示
- 查询表：查询结果对应的表
- 视图表：由基本表或其他视图表导出的表，是虚表，不对应实际存储的数据

## 关系模式

- 数据库中需要区分型和值，关系模式是型，关系是值
- 关系模式是对关系的描述
  - 元组集合的结构：属性构成、属性来自的域、属性与域之间的映象关系
  - 完整性约束条件
- 关系模式的形式化表示：$R(U, D, DOM,F)$
  - R：关系名
  - U：组成该关系的属性名集合
  - D：U 中属性所来自的域
  - DOM：属性向域的映象集合
  - F：属性间数据的依赖关系的集合
- 关系是关系模式在某一时刻的状态或内容。
  - 关系模式是静态的、稳定的
  - 而关系是动态的、随时间不断变化的，因为关系操作在不断地更新着数据库中的数据
  - 例如，学生关系模式在不同的学年，学生关系是不同的。
- 在实际工作中，人们常常把关系模式和关系都笼统地称为关系，这不难从上下文中加以区别，希望读者注意。

# 关系操作

## 基本的关系操作

- 查询（query）
  - 5 种基本操作
    - 选择（selection）
    - 投影（projection）
    - 并（union）
    - 差（difference）
    - 笛卡尔积
  - 其他操作，可用基本操作定义和导出
    - 连接（join）
    - 除（divide）
    - 交（intersection）
- 插入（insert）、删除（delete）、修改（update）

关系操作的特点是集合操作方式，即操作的对象和结果都是集合。这种操作方式也称为一次一集合（sct-at-a-time）的方式。相应地，非关系数据模型的数据操作方式则为一次一记录（record-at-a-time）的方式。

## 关系数据库语言的分类

- **关系代数语言**： 用对关系的运算来表达查询要求（代表：ISBL）
- **关系演算语言**：用谓词来表达查询要求
  - **元组关系演算语言**：谓词变元的基本对象是元组变量（代表：APLHA, QUEL）
  - **域关系演算语言**：谓词变元的基本对象是域变量（代表：QBE）
- **具有关系代数和关系演算双重特点的语言**（代表：SQL）

# 关系的完整性

## 实体完整性

实体完整性规则（Entity Integrity）

- 若属性 A 是基本关系 R 的主属性，则属性 A 不能取空值
- 空值就是“不知道”或“不存在”或“无意义”的值

说明：

1. 实体完整性规则是针对基本关系而言的。一个基本表通常对应现实世界的一个实体集。
2. 现实世界中的实体是可区分的，即它们具有某种唯一性标识。
3. 关系模型中以主码作为唯一性标识。
4. 主码中的属性即主属性不能取空值。主属性取空值，就说明存在某个不可标识的实体，即存在不可区分的实体，这与第 2 点相矛盾，因此这个规则称为实体完整性

## 参照完整性

**关系间的引用**：

- 在关系模型中实体及实体间的联系都是用关系来描述的，自然存在着关系与关系间的引用。
- 例如：
  - 学生实体：学生（学号，姓名，性别，_专业号_，年龄）
  - 专业实体：专业（_专业号_，专业名）
  - 学生关系引用了专业关系的主码“专业号”
  - 学生关系中的“专业号”值必须是确实存在的专业的专业号

**外码（foreign key）**：

- 设 $F$ 是基本关系 $R$ 的一个或一组属性，但不是关系 $R$ 的码。
- 如果 $F$ 与基本关系 $S$ 的主码 $K_S$ 相对应，则称 $F$ 是 $R$ 的外码
- 基本关系 $R$ 称为**参照关系**（Referencing Relation）
- 基本关系 $S$ 称为**被参照关系**（Referenced Relation）或**目标关系**（Target Relation）
- 注意：
  - 关系 $R$ 和 $S$ 不一定是不同的关系
  - 目标关系 $S$ 的主码 $K_S$ 和参照关系的外码 $F$ 必须定义在同一个（或一组）域上，即同一个数据模型
  - 外码并不一定要与相应的主码同名。当外码与相应的主码属于不同关系时，往往取相同的名字，以便于识别

**参照完整性规则**：
若属性（或属性组）$F$ 是基本关系 $R$ 的外码它与基本关系 $S$ 的主码 $K_S$ 相对应（$R$ 和 $S$ 可以相同），则对于 $R$ 中每个元组在 $F$ 上的值必须为：

- 或者取空值（$F$ 的每个属性值均为空值）
- 或者等于 $S$ 中某个元组的主码值

## 用户自定义的完整性

- 针对某一具体关系数据库的约束条件，反映某一具体应用所涉及的数据必须满足的语义要求
- 关系模型应提供定义和检验这类完整性的机制，以便用统一的系统的方法处理它们，而不需由应用程序承担这一功能

# 关系代数

关系代数是一种抽象的查询语言，它用对关系的运算来表达查询

- 运算对象是关系
- 运算结果亦为关系
- 关系代数的运算符有两类：集合运算符和专门的关系运算符
  - 集合运算是从关系的“水平”方向即行的角度进行
  - 专门的关系运算不仅涉及行而且涉及列

**引入记号**：

- $R(A_1, A_2, \dotso, A_n)$
  > 关系模式
- $R$
  > 关系
- $t$
  > 元组
  > $t \in R$
- $t[A_i]$
  > $t$ 中相应于属性 $A_i$ 的一个分量
- $A$
  > 属性列 / 属性组
  > $A = \{A_{i1}, A_{i2}, \dotso, A_{ik}\}$
  > 一个属性列是分量集合，是 $A_1, A_2, \dotso, A_n$ 的一部分
- $t[A]$
  > $t[A]=(t[A_{i1}], t[A_{i2}], \dotso, t[A_{ik}])$
  > 表示元组 $t$ 在属性列 $A$ 上各个分量的集合
- $\overline{A}$
  > $\{A_1, A_2, \dotso, A_n\} - A$
- $S$
  > 另一个关系
- $\overgroup{t_r \: t_s}$

  > 元组的连接
  > $t_r \in R, t_s \in S$
  > 示例：
  >
  > > 若：$t_{r_1} = \{a_1, b_1, c_1\}, t_{s_1} = \{c_1, d_1\}$
  > > 则：$\overgroup{t_{r_1} \: t_{s_1}} = \{a_1, b_1, c_1, c_1, d_1\}$

- $Z_X$
  > 象集（Images Set）
  > 给定一个关系 $R(X, Z)$，$X, Z$ 为 $R$ 的属性组，则 $Z_X = \{t[Z] \: | \: t \in R, \: t[X] = x\}$
  > 表示 $R$ 中属性组 $X$ 上值为 $x$ 时另一个属性组 $Z$ 上的值的集合，即当 $X = x$ 时 $Z$ 的所有取值
  > 示例：
  >
  > > 若：$R$
  > > |X|Z|
  > > |---|---|
  > > |$x_1$|$z_1$|
  > > |$x_1$|$z_2$|
  > > |$x_1$|$z_3$|
  > > |$x_2$|$z_2$|
  > > |$x_2$|$z_3$|
  > > 则：
  > > $x_1$ 在 $R$ 中的象集 $Z_{x_1} = \{z_1, z_2, z_3\}$ >> $x_2$ 在 $R$ 中的象集 $Z_{x_2} = \{z_2, z_3\}$

## 传统的集合运算

传统的集合运算术语二目运算，包括并、差、交、笛卡尔积四种

| 运算                          | 运算符   |
| ----------------------------- | -------- |
| 并（union）                   | $\cup$   |
| 差（difference）              | $-$      |
| 交（intersection）            | $\cap$   |
| 笛卡尔积（cartesian product） | $\times$ |

### 并（Union）

$R \cup S = \{t \: | \: t \in R \lor t \in S\}$

> - 要求：具有相同的目 $n$（即都有 $n$ 个属性），相应的属性取自同一个域（即数据模型相同）
> - 结果：仍未 $n$ 目关系，由属于关系 $R$ 和 $S$ 的元组共同组成

### 差（Difference）

$R - S = \{t \: | \: t \in R \land t \notin S\}$

> - 要求：具有相同的目 $n$（即都有 $n$ 个属性），相应的属性取自同一个域（即数据模型相同）
> - 结果：仍未 $n$ 目关系，由属于关系 $R$ 且不属于 $S$ 的元组组成

### 交（Intersection）

$R \cap S = \{t \: | \: t \in R \land t \in S\}$

> - 要求：具有相同的目 $n$（即都有 $n$ 个属性），相应的属性取自同一个域（即数据模型相同）
> - 结果：仍未 $n$ 目关系，由属于关系 $R$ 且属于 $S$ 的元组组成
> - 用差表示：$R \cap S = R - (R - S)$

### 笛卡尔积（Extended Cartesian Product）

$R \times S = \{\overgroup{t_r \: t_s} \: | \: t_r \in R \land t_s \in S\}$

> - 这里的笛卡尔积为**广义笛卡尔积**（extended cartesian product），这里的笛卡尔积为元素的元组，而非域
> - 要求：无要求，即关系 $R$ 和 $S$ 的目可以不相同，且属性也不要求对应。
> - 若： $R$ 为 $m$ 目关系，拥有 $k_1$ 个元组；$S$ 为 $n$ 目关系，有 $k_2$ 个元组
> - 结果：为 $(m + n)$ 目关系（前 $m$ 来自 $R$ 的某一个 $m$ 元组，后 $n$ 个来自 $S$ 的某一个 $n$ 元组），拥有 $k_1 \times k_2$ 个元组

**示例**：
- $R$

  | $A$   | $B$   | $C$   |
  | ----- | ----- | ----- |
  | $a_1$ | $b_1$ | $c_1$ |
  | $a_2$ | $b_2$ | $c_2$ |
  | $a_3$ | $b_3$ | $c_3$ |
- $S$

  | $A$   | $B$   |
  | ----- | ----- |
  | $a_4$ | $b_4$ |
  | $a_5$ | $b_5$ |
- $R \times S$

  | $R.A$ | $R.B$ | $R.C$ | $S.A$ | $S.B$ |
  | ----- | ----- | ----- | ----- | ----- |
  | $a_1$ | $b_1$ | $c_1$ | $a_4$ | $b_4$ |
  | $a_1$ | $b_1$ | $c_1$ | $a_5$ | $b_5$ |
  | $a_2$ | $b_2$ | $c_2$ | $a_4$ | $b_4$ |
  | $a_2$ | $b_2$ | $c_2$ | $a_5$ | $b_5$ |
  | $a_3$ | $b_3$ | $c_3$ | $a_4$ | $b_4$ |
  | $a_3$ | $b_3$ | $c_3$ | $a_5$ | $b_5$ |

## 专门的关系运算

| 运算               | 运算符   |
| ------------------ | -------- |
| 选择（selection）  | $\sigma$ |
| 投影（projection） | $\pi$    |
| 连接（join）       | $\Join$  |
| 除（division）     | $\div$   |

### 选择（Selection）

$\sigma_F(R) = \{t \: | \: t \in R \land F(t) = true\}$

> - 选择又称为限制（Restriction）
> - 含义：在关系 $R$ 中选择满足给定条件的各个元组
> - $F$：选择条件，是一个逻辑表达式，取值为`true(真)`或`false（假）`。基本形式为：X $\theta$ Y，$\theta$ 表示比较运算符，它可以是 `>`, `>=`, `<`, `<=`, `=` 或 `<>`

**示例**：
- $Student$

  | 学号 Sno  | 姓名 Sname | 性别 Ssex | 年龄 Sage | 所在系 Sdept |
  | --------- | ---------- | --------- | --------- | ------------ |
  | 201215121 | 李勇       | 男        | 20        | CS           |
  | 201215122 | 刘晨       | 女        | 19        | CS           |
  | 201215123 | 王敏       | 女        | 18        | MA           |
  | 201215125 | 张立       | 男        | 19        | IS           |
- $\sigma_{Sdept = 'IS'}(Student)$

  | 学号 Sno  | 姓名 Sname | 性别 Ssex | 年龄 Sage | 所在系 Sdept |
  | --------- | ---------- | --------- | --------- | ------------ |
  | 201215125 | 张立       | 男        | 19        | IS           |
- $\sigma_{Sage < 20}(Student)$

  | 学号 Sno  | 姓名 Sname | 性别 Ssex | 年龄 Sage | 所在系 Sdept |
  | --------- | ---------- | --------- | --------- | ------------ |
  | 201215122 | 刘晨       | 女        | 19        | CS           |
  | 201215123 | 王敏       | 女        | 18        | MA           |
  | 201215125 | 张立       | 男        | 19        | IS           |

### 投影（Projection）

$\pi_{A}(R) = \{t[A]  \: | \:  t \in R\}$

> - 从 $R$ 中选择出若干属性列（$t[A]$）组成新的关系
> - 投影操作主要是从列的角度进行运算
> - 投影之后不仅取消了原关系中的某些列，而且还可能取消某些元组（避免重复行）

**示例**：
- $\pi_{Sname, Sdept}(Student)$

  | Sname | Sdept |
  | ----- | ----- |
  | 李勇  | CS    |
  | 刘晨  | CS    |
  | 王敏  | MA    |
  | 张立  | IS    |

### 连接（Join）

$R {\Join \atop {A \: \theta \: B}} S = \{\overgroup{t_r \: t_s} \: | \: t_r \in R \land t_s \in S \land t_r[A] \: \theta \: t_s[B]\}$

> - 记号：
>   - $A$ 和 $B$：分别为 $R$ 和 $S$ 上度数相等且可比的属性组
>   - $θ$：比较运算符
> - 含义：从两个关系的笛卡尔积中选取属性间满足一定条件的元组
> - 连接运算从 $R$ 和 $S$ 的广义笛卡尔积 $R \times S$ 中选取 $R$ 关系在 $A$ 属性组上的值与 $S$ 关系在 $B$ 属性组上的值满足比较关系 $θ$ 的元组

#### 等值连接（Equijoin）

$R {\Join \atop \ {A = B}} S = \{\overgroup{t_r \: t_s} \: | \: t_r \in R \land t_s \in S \land t_r[A] = t_s[B]\}$

> - $θ$ 为 `＝` 的连接运算称为等值连接（equijoin）
> - 从关系 $R$ 与 $S$ 的广义笛卡尔积中选取 $A$、$B$ 属性值相等的那些元组，即等值连接为

**示例**：
- $R$

  | $\bold{A}$ | $\bold{B}$ | $\bold{C}$ |
  | ---------- | ---------- | ---------- |
  | $a_1$      | $b_1$      | $5$        |
  | $a_1$      | $b_2$      | $6$        |
  | $a_2$      | $b_3$      | $8$        |
  | $a_2$      | $b_4$      | $12$       |
- $S$

  | $\bold{B}$ | $\bold{E}$ |
  | ---------- | ---------- |
  | $b_1$      | $3$        |
  | $b_2$      | $7$        |
  | $b_3$      | $10$       |
  | $b_3$      | $2$        |
  | $b_2$      | $2$        |
- $R {\Join \atop \ {R.B = S.B}} S$

  | $\bold{A}$ | $\bold{R.B}$ | $\bold{C}$ | $\bold{S.B}$ | $\bold{E}$ |
  | ---------- | ------------ | ---------- | ------------ | ---------- |
  | $a_1$      | $b_1$        | $5$        | $b_1$        | $3$        |
  | $a_1$      | $b_2$        | $6$        | $b_2$        | $7$        |
  | $a_2$      | $b_3$        | $8$        | $b_3$        | $10$       |
  | $a_2$      | $b_3$        | $8$        | $b_3$        | $2$        |



#### 自然连接（Natural Join）

$R \Join S = \{\overgroup{t_r \: t_s}[U - B] \: | \: t_r \in R \land t_s \in S \land t_r[A] \: = \: t_s[B]\}$

> - 记号：
>   - $B$：关系 $R$ 和 $S$ 共有的属性组
>   - $U$：关系 $R$ 和 $S$ 所有的属性组（包括共有的属性组）
> - 自然连接（natural join）是一种特殊的等值连接
>   - 两个关系中进行比较的分量必须是相同的属性组
>   - 在结果中把重复的属性列去掉

**示例**：
- $R \Join S$：在等值连接的结果上去除重复的列

  | $\bold{A}$ | $\bold{B}$ | $\bold{C}$ | $\bold{E}$ |
  | ---------- | ---------- | ---------- | ---------- |
  | $a_1$      | $b_1$      | $5$        | $3$        |
  | $a_1$      | $b_2$      | $6$        | $7$        |
  | $a_2$      | $b_3$      | $8$        | $10$       |
  | $a_2$      | $b_3$      | $8$        | $2$        |

##### 悬浮元组

自然连接（$R \Join S$）时，关系 $R$ 中某些元组有可能在 $S$ 中不存在公共属性上值相等的元组（$t_r[A]$ 存在，但 $t_r[A] = t_s[B]$ 不存在），从而造成 $R$ 中这些元组在操作时被舍弃了。同样，$S$ 中某些元组也可能被舍弃。这些被舍弃的元组称为悬浮元组（dangling tuple）

##### 外连接（Outer Join）

outer join
保留 $R$ 和 $S$ 的悬浮元组，在相应属性中填充 `NULL` 值

**示例**：
- $R \Join S$：在自然连接的结果上添加 $R$ 和 $S$ 的悬浮元组

  | $\bold{A}$ | $\bold{B}$ | $\bold{C}$ | $\bold{E}$ |
  | ---------- | ---------- | ---------- | ---------- |
  | $a_1$      | $b_1$      | $5$        | $3$        |
  | $a_1$      | $b_2$      | $6$        | $7$        |
  | $a_2$      | $b_3$      | $8$        | $10$       |
  | $a_2$      | $b_3$      | $8$        | $2$        |
  | $a_2$      | $b_4$      | $12$       | $NULL$     |
  | $NULL$     | $b_5$      | $NULL$     | $2$        |

##### 左外连接（Left Join）

left outer join 或 left join
只保留 $R$ 的悬浮元组，在 $S$ 相应属性中填充 `NULL` 值

**示例**：
- $R \Join S$：在自然连接的结果上添加 $R$的悬浮元组

  | $\bold{A}$ | $\bold{B}$ | $\bold{C}$ | $\bold{E}$ |
  | ---------- | ---------- | ---------- | ---------- |
  | $a_1$      | $b_1$      | $5$        | $3$        |
  | $a_1$      | $b_2$      | $6$        | $7$        |
  | $a_2$      | $b_3$      | $8$        | $10$       |
  | $a_2$      | $b_3$      | $8$        | $2$        |
  | $a_2$      | $b_4$      | $12$       | $NULL$     |

##### 右外连接（Right Join）

right outer join 或 right join
只保留 $S$ 的悬浮元组，在 $R$ 相应属性中填充 `NULL` 值

**示例**：
- $R \Join S$：在自然连接的结果上添加 $S$ 的悬浮元组

  | $\bold{A}$ | $\bold{B}$ | $\bold{C}$ | $\bold{E}$ |
  | ---------- | ---------- | ---------- | ---------- |
  | $a_1$      | $b_1$      | $5$        | $3$        |
  | $a_1$      | $b_2$      | $6$        | $7$        |
  | $a_2$      | $b_3$      | $8$        | $10$       |
  | $a_2$      | $b_3$      | $8$        | $2$        |
  | $NULL$     | $b_5$      | $NULL$     | $2$        |

### 除（Division）

$R \div S = \{t_r[X] \: | \: t_r \in R \land \pi_Y(S) \subseteq Y_X\}$

> - 给定关系 $R(X, Y)$ 和 $S(Y, Z)$。$X$、$Y$、$Z$ 为属性组，其中 $Y$ 表示共有属性组
>   - $R$ 中的 $Y$ 与 $S$ 中的 $Y$ 可以有不同的属性名，但必须出自相同的域集
>   - $R$ 与 $S$ 的除运算得到一个新的关系 $P(X)$
> - $P$ 是 $R$ 中满足下列条件的元组在 $X$ 属性列上的投影：
>   - 当 $X = x$ 时，$x$ 在 $R$ 中的象集 $Y_x$ 在 $S$ 的投影 $\pi_Y(S)$ 中存在，即 $Y_x$ 和 $\pi_Y(S)$ 的交集不为空
>   - 换一种表达方法：$R \div S = \{t_r[X] \: | \: t_r \in R \land \pi_Y(S) \cap Y_X \ne \empty\}$

**示例**：
- $R$

  | $\bold{A}$ | $\bold{B}$ | $\bold{C}$ |
  | ---------- | ---------- | ---------- |
  | $a_1$      | $b_1$      | $c_2$      |
  | $a_2$      | $b_3$      | $c_7$      |
  | $a_3$      | $b_4$      | $c_6$      |
  | $a_1$      | $b_2$      | $c_3$      |
  | $a_4$      | $b_6$      | $c_6$      |
  | $a_2$      | $b_2$      | $c_3$      |
  | $a_1$      | $b_2$      | $c_1$      |
- $S$

  | $\bold{B}$ | $\bold{C}$ | $\bold{D}$ |
  | ---------- | ---------- | ---------- |
  | $b_1$      | $c_2$      | $d_1$      |
  | $b_2$      | $c_1$      | $d_1$      |
  | $b_2$      | $c_3$      | $d_2$      |
- $A$ 在 $R$ 中的象集 $T_A$（$\: T = \{B, C\}$）

  | $\bold{A}$ | $\bold{T_A}$                             |
  | ---------- | ---------------------------------------- |
  | $a_1$      | $\{(b_1, c_2), (b_2, c_3), (b_2, c_1)\}$ |
  | $a_2$      | $\{(b_3, c_7), (b_2, c_3)\}$             |
  | $a_3$      | $\{(b_4, c_6)\}$                         |
  | $a_4$      | $\{(b_6, c_6)\}$                         |
- $S$ 在 $B, C$ 上的投影 $\pi_{B, C}(S)$

  |$\bold{\pi_{B, C}(S)}$|
  |---|
  |$(b_1, c_2)$|
  |$(b_2, c_1)$|
  |$(b_2, c_3)$|
- $T_A$ 和 $\pi_{B, C}(S)$ 的交集

  | $\bold{A}$ | $\bold{T_A \cap \pi_{B, C}(S)}$ |
  | ---------- | ------------------------------- |
  | $a_1$      | $\{(b_1, c_2)\}$                |
  | $a_2$      | $\empty$                        |
  | $a_3$      | $\empty$                        |
  | $a_4$      | $\empty$                        |
- 所以 $R \div S$ 的结果为

  |$\bold{R \div S}$|
  |---|
  |$a_1$|

# 关系演算

## 元组关系演变运算语言 ALPHA

**主要语句**：
- GET
- PUT
- HOLD
- UPDATE
- DELETE
- DROP

**语句的基本格式**：
- `操作语句 工作空间名 (表达式)：操作条件`
- 例如：
    - 查询 1 个所在系为 IS 的学生的 Sno 和 Sname
    - `GET W (1)(Student.Sno, Student.Sname): Student.Sdept = 'IS'`


## 元组关系演变运算

## 域关系演变运算语言 QBE