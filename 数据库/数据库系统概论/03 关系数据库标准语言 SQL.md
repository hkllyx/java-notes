- [概述](#概述)
  - [SQL 四部分](#sql-四部分)
    - [数据定义语言（DDL）](#数据定义语言ddl)
    - [数据操作语言（DML）](#数据操作语言dml)
    - [数据控制语言（DCL）](#数据控制语言dcl)
    - [事务控制语言（TCL）](#事务控制语言tcl)
  - [SQL 特点](#sql-特点)
    - [综合统一](#综合统一)
    - [高度非过程化](#高度非过程化)
    - [面向集合的操作方式](#面向集合的操作方式)
    - [以同一种语法结构提供多种使用方式](#以同一种语法结构提供多种使用方式)
    - [语言简洁，易学易用](#语言简洁易学易用)
  - [SQL 基本概念](#sql-基本概念)
    - [存储文件](#存储文件)
    - [基本表](#基本表)
    - [视图](#视图)
- [数据定义](#数据定义)
  - [模式](#模式)
    - [定义](#定义)
    - [删除](#删除)
  - [基本表](#基本表-1)
    - [定义](#定义-1)
    - [数据类型](#数据类型)
    - [修改](#修改)
    - [删除](#删除-1)
  - [索引](#索引)
    - [定义](#定义-2)
    - [删除](#删除-2)
  - [数据字典](#数据字典)
- [数据查询](#数据查询)
  - [单表查询](#单表查询)
  - [连接查询](#连接查询)
  - [嵌套查询](#嵌套查询)
  - [集合查询](#集合查询)
  - [基于派生表的查询](#基于派生表的查询)
- [数据更新](#数据更新)
  - [插入数据](#插入数据)
    - [插入元组](#插入元组)
    - [插入子查询结果](#插入子查询结果)
  - [修改数据](#修改数据)
  - [删除数据](#删除数据)
- [空值处理](#空值处理)
- [视图](#视图-1)
  - [定义](#定义-3)
  - [删除](#删除-3)
  - [查询](#查询)
  - [更新](#更新)
  - [视图的作用](#视图的作用)

# 概述

SQL（Structured Query Language）结构化查询语言，是关系数据库的标准语言。是一个通用的、功能极强的关系数据库语言。

## SQL 四部分

### 数据定义语言（DDL）

Data Definition Language
- 用于定义数据库的三级结构，包括外模式、概念模式、内模式及其相互之间的映像
- 定义数据的完整性、安全控制等约束
- DDL 不需要 commit
- 语句：
    - **CREATE**
    - **DROP**
    - **ALTER**
    - RENAME
    - TRUNCATE
    - COMMENT

### 数据操作语言（DML）

Data Manipulation Language
- 由 DBMS 提供，用于让用户或程序员使用，实现对数据库中数据的操作
- DML 分成交互型 DML 和嵌入型 DML 两类。
- 依据语言的级别，DML 又可分成过程性 DML 和非过程性 DML 两种
- 需要 commit
- 语句：
    - **SELECT**
    - **INSERT**
    - **UPDATE**
    - **DELETE**
    - MERGE
    - CALL
    - EXPLAIN PLAN
    - LOCK TABLE

### 数据控制语言（DCL）

Data Control Language
- 数据库控制语言  授权，角色控制等
- 语句：
    - **GRANT**
    - **REVOKE**

### 事务控制语言（TCL）

Transaction Control Language
- 语句：
    - **SAVEPOINT**
    - **ROLLBACK**
    - **COMMIT**
    - **SET TRANSACTION**

## SQL 特点

### 综合统一

- 集数据定义语言（DDL），数据操纵语言（DML），数据控制语言（DCL）功能于一体。
- 可以独立完成数据库生命周期中的全部活动：
    - 定义和修改、删除关系模式，定义和删除视图，插入数据，建立数据库;
    - 对数据库中的数据进行查询和更新;
    - 数据库重构和维护
    - 数据库安全性、完整性控制，以及事务控制
    - 嵌入式 SQL 和动态 SQL 定义
- 用户数据库投入运行后，可根据需要随时逐步修改模式，不影响数据库的运行。
- 数据操作符统一

### 高度非过程化

- 非关系数据模型的数据操纵语言“面向过程”，必须指定存取路径。
- SQL 只要提出“做什么”，无须了解存取路径。
- 存取路径的选择以及SQL的操作过程由系统自动完成。

### 面向集合的操作方式

- 非关系数据模型采用面向记录的操作方式，操作对象是一条记录
- SQL 采用集合操作方式
- 操作对象、查找结果可以是元组的集合
- 一次插入、删除、更新操作的对象可以是元组的集合

### 以同一种语法结构提供多种使用方式

- SQL 是独立的语言：能够独立地用于联机交互的使用方式
- SQL 又是嵌入式语言：能够嵌入到高级语言（例如 C，C++，Java）程序中，供程序员设计程序时使用

### 语言简洁，易学易用

- SQL 功能极强，完成核心功能只用了 9 个动词

    | 功能                   | 动词                   |
    | ---------------------- | ---------------------- |
    | 数据查询（Query）      | SELECT                 |
    | 数据定义（Definition） | CREATE, DROP, ALTER    |
    | 数据操纵（Manipulate） | INSERT, UPDATE, DELETE |
    | 数据控制（Control）    | GRANT, REVOKE          |

## SQL 基本概念

支持 SQL 的关系数据库管理系统同样支持关系数据库三级模式结构。
- 外模式包括若干视图（view）和部分基本表（base table）
- 数据库模式包括若干基本表
- 内模式包括若干存储文件（stored file）。

![](img/009.png)

### 存储文件

- 逻辑结构组成了关系数据库的内模式
- 物理结构对用户是隐蔽的

### 基本表

- 本身独立存在的表
- SQL 中一个关系就对应一个基本表
- 一个（或多个）基本表对应一个存储文件
- 一个表可以带若干索引

### 视图

- 从一个或几个基本表导出的表
- 数据库中只存放视图的定义而不存放视图对应的数据
- 视图是一个虚表
- 用户可以在视图上再定义视图

# 数据定义

| 操作对象 | 创建          | 删除        | 修改        |
| -------- | ------------- | ----------- | ----------- |
| 模式     | CREATE SCHEMA | DROP SCHEMA |             |
| 表       | CREATE TABLE  | DROP TABLE  | ALTER TABLE |
| 视图     | CREATE VIEW   | DROP VIEW   |             |
| 索引     | CREATE INDEX  | DROP INDEX  | ALTER INDEX |

现代关系数据库管理系统提供了一个层次化的数据库对象命名机制
- 一个关系数据库管理系统的实例（Instance）中可以建立多个数据库
- 一个数据库中可以建立多个模式
- 一个模式下通常包括多个表、视图和索引等数据库对象
- DBMS 实例 $\overset{1 对 n}{\Longrightarrow}$ 数据库 $\overset{1 对 n}{\Longrightarrow}$ 模式 $\overset{1 对 n}{\Longrightarrow}$ 表、视图和索引等

## 模式

### 定义

```
CREATE SCHEMA [<模式名>] AUTHORIZATION <用户名>
    [<CREATE TABLE 子句> | <CREATE VIEW 子句> | <GRANT 子句>]
```
> - <模式名> 省略时默认为 <用户名>
> - 定义模式实际上定义了一个**命名空间**
> - 在这个空间中可以定义该模式包含的数据库对象，例如基本表、视图、索引等。

### 删除

```
DROP SCHEMA <模式名> <CASCADE | RESTRICT>
```
> - CASCADE 和 RESTRICT 必选其一
> - CASCADE（级联）：删除模式的同时把该模式中所有的数据库对象全部删除
> - RESTRICT（限制）：如果该模式中定义了下属的数据库对象（如表、视图等），则拒绝该删除语句的执行。仅当该模式中没有任何下属的对象时才能执行。

## 基本表

### 定义

```
CREATE TABLE [<模式名>.]<表名> (
    <列名> <数据类型> [<列级完整性约束条件>]
    ...
    [, <列名> <数据类型> [<列级完整性约束条件>]]
    ...
    [, <表级完整性约束条件>])
    ...;
```
> - <模式名>
>     - 若没有指定模式，系统根据**搜索路径**来确定该对象所属的模式search_path;`
>     - 关系数据库管理系统会使用模式列表中**第一个存在的模式**作为数据库对象的模式名
>     - 若搜索路径中的模式名都不存在，系统将给出错误
>         - 显示当前的搜索路径：`SHOW search_path;`
>         - 搜索路径的当前默认值是：`$user, PUBLIC`
>     - 数据库管理员用户可以设置搜索路径，然后定义基本表
>         - **设置搜索路径**：`SET search_path TO <搜索路径>`
> - <表名>：所要定义的基本表的名字
> - <列名>：组成该表的各个属性（列）
> - <列级完整性约束条件>：涉及相应属性列的完整性约束条件
> - <表级完整性约束条件>：涉及一个或多个属性列的完整性约束条件
> - 如果完整性约束条件涉及到该表的多个属性列，则必须定义在表级上，否则既可以定义在列级也可以定义在表级

### 数据类型

- SQL 中域的概念用数据类型来实现
- 定义表的属性时需要指明其数据类型及长度
- 选用哪种数据类型
    - 取值范围
    - 要做哪些运算

| 数据类型                        | 含义                                                               |
| ------------------------------- | ------------------------------------------------------------------ |
| CHAR(n), CHARACTER(n)           | 长度为 n 的定长字符串                                              |
| VARCHAR(n), CHARACTERVARYING(n) | 最大长度为 n 的变长字符串                                          |
| CLOB                            | 字符串大对象                                                       |
| BLOB                            | 二进制大对象                                                       |
| INT，INTEGER                    | 长整数（4 字节）                                                   |
| SMALLINT                        | 短整数（2 字节）                                                   |
| BIGINT                          | 大整数（8 字节）                                                   |
| NUMERIC(p，d)                   | 定点数，由 p 位数字（不包括符号、小数点）组成，小数后面有 d 位数字 |
| DECIMAL(p, d), DEC(p, d)        | 同 NUMERIC                                                         |
| REAL                            | 取决于机器精度的单精度浮点数                                       |
| DOUBLE PRECISION                | 取决于机器精度的双精度浮点数                                       |
| FLOAT(n)                        | 可选精度的浮点数，精度至少为 n 位数字                              |
| BOOLEAN                         | 逻辑布尔量                                                         |
| DATE                            | 日期，包含年、月、日。格式为 `YYYY-MM-DD`                          |
| TIME                            | 时间，包含一日的时、分、秒。格式为 `HH:MM:SS`                      |
| TIMESTAMP                       | 时间戳类型                                                         |
| INTERVAL                        | 时间间隔类型                                                       |

### 修改

```
ALTER TABLE <表名>
    [ADD [COLUMN] <新列名> <数据类型> [完整性约束]]
    [ADD <表级完整性约束>]
    [DROP [COLUMN] <列名> [CASCADE | RESTRICT]]
    [DROP CONSTRAINT <完整性约束名> [RESTRICT | CASCADE]]
    [ALTER COLUMN <列名> <数据类型>] ;
```
> - <表名> 是要修改的基本表
> - ADD 子句用于增加新列、新的列级完整性约束条件和新的表级完整性约束条件
> - DROP COLUMN 子句用于删除表中的列
>     - 如果指定了 CASCADE 短语，则自动删除引用了该列的其他对象
>     - 如果指定了 RESTRICT 短语，则如果该列被其他对象引用，关系数据库管理系统将拒绝删除该列
> - DROP CONSTRAINT 子句用于删除指定的完整性约束条件
> - ALTER COLUMN 子句用于修改原有的列定义，包括修改列名和数据类型

### 删除

```
DROP TABLE <表名> [CASCADE | RESTRICT];
```
> - CASCADE：删除该表没有限制。
>     - 在删除基本表的同时，相关的依赖对象一起删除
>     - 表上建立的索引、视图、触发器等一般也将被删除
> - RESTRICT：删除表是有限制的。
>     - 欲删除的基本表不能被其他表的约束所引用
>     - 如果存在依赖该表的对象，则此表不能被删除

![](img/010.png)
- R 表示 RESTRICT, C 表示 CASCADE
- 空 '' 表示不能删除基本表，对勾 '$\surd$' 表示能删除基本表，'保留' 表示删除基本表后，还保留依赖对象

## 索引

- 建立索引的目的：加快查询速度
- 关系数据库管理系统中常见索引：
    - 顺序文件上的索引
    - B+ 树索引
    - 散列（hash）索引
    - 位图索引
- 特点：
    - B+ 树索引具有动态平衡的优点
    - HASH 索引具有查找速度快的特点
- 谁可以建立索引：数据库管理员 或 表的属主（即建立表的人）
- 谁维护索引：关系数据库管理系统自动完成
- 使用索引：关系数据库管理系统自动选择合适的索引作为存取路径，用户不必也不能显式地选择索引

### 定义

```
CREATE [UNIQUE] [CLUSTER] INDEX <索引名>
    ON <表名>(<列名> [<次序>] [, <列名> [<次序>]]...);
```
> - <表名>：要建索引的基本表的名字
> - INDEX：可以建立在该表的一列或多列上，各列名之间用逗号分隔
> - <次序>：指定索引值的排列次序，升序：ASC，降序：DESC。缺省值：ASC
> - UNIQUE：此索引的每一个索引值只对应唯一的数据记录
> - CLUSTER：表示要建立的索引是聚簇索引

### 删除

```
DROP INDEX <索引名>;
```
> - 删除索引时，系统会从数据字典中删去有关该索引的描述

## 数据字典

数据字典是关系数据库管理系统内部的一组系统表，它记录了数据库中所有定义信息：
    - 关系模式定义
    - 视图定义
    - 索引定义
    - 完整性约束定义
    - 各类用户对数据库的操作权限
    - 统计信息等

关系数据库管理系统在执行SQL的数据定义语句时，实际上就是在更新数据字典表中的相应信息。

# 数据查询

```
SELECT [ALL | DISTINCT] <目标列表达式> [[AS] <别名>] [, <目标列表达式> [[AS] <别名>]]...
    FROM <表名或视图名> [[AS] <别名>] [, <表名或视图名> [[AS] <别名>]]...| (SELECT 语句)
    [AS] <别名>
    [WHERE <条件表达式>]
    [GROUP BY <列名 1> [HAVING <条件表达式>]]
    [ORDER BY <列名 2> [ASC | DESC]];
```
> - SELECT 子句：指定要显示的属性列
> - FROM 子句：指定查询对象（基本表或视图，或者是嵌套的 SELECT 语句）
> - WHERE 子句：指定查询条件
> - GROUP BY 子句：对查询结果按指定列的值分组，该属性列值相等的元组为一个组。通常会在每组中作用聚集函数
> - HAVING 短语：只有满足指定条件的组才予以输出，依赖于 GROUP BY 子句
> - ORDER BY 子句：对查询结果表按指定列值的升序或降序排序

## 单表查询

- 选择表中的若干列：SELECT 子句
    - 查询特定列
      ```
      SELECT <目标列>
      ```
    - 查询所有列，可以使用 `*` 通配符
      ```
      SELECT {所有列 | *}
      ```
    - 查询经过计算的值：表达式中可以使用聚合函数和算术运算符
      ```
      SELECT <目标列表达式>
      ```
- 选择表中的若干元组（行）
    - 消除取值重复的行：SELECT 子句
      ```
      SELECT DISTINCT
      ```
    - 查询满足条件的元组：WHERE 子句
      ```
      WHERE <条件表达式> [{AND | OR} <条件表达式>]...
      ```
      > | 查 询 条 件          | 运 算 符（谓 词）                                                         | 示 例                      |
      > | -------------------- | ------------------------------------------------------------------------- | -------------------------- |
      > | 比 较                | `=`, `>`, `<`, `>=`, `<=`, `!=`, `<>`, `!>`, `!<`; `NOT + 上述比较运算符` | `age > 20`                 |
      > | 确定范围             | `BETWEEN AND`, `NOT BETWEEN AND`                                          | `age BETWEEN 20 AND 40`    |
      > | 确定集合             | `IN`, `NOT IN`                                                            | `age IN (10, 20, 30)`      |
      > | 字符匹配             | `LIKE`, `NOT LIKE`（不使用通配符时，`LIKE` 可以使用`=` 代替 ）            | `name LIKE 'X_%'`          |
      > | 空 值                | `IS NULL`, `IS NOT NULL`（`IS` 不能使用`=` 代替 ）                        | `name IS NOT NULL`         |
      > | 多重条件（逻辑运算） | `AND`, `OR`, `NOT`                                                        | `age = 20 AND name = 'XY'` |
- ORDER BY 子句
    ```
    ORDER BY <列名 1> [ASC | DESC] [, <列名 2> [ASC | DESC]]...
    ```
    > - 可以按一个或多个属性列排序
    > - 升序 ASC，降序 DESC，缺省值为 ASC
    > - 对于空值，排序时显示的次序由具体系统实现来决定
- 聚集函数

  | 函数  | 功能                                   | 语句                             |
  | ----- | -------------------------------------- | -------------------------------- |
  | COUNT | 统计元组个数                           | `COUNT(*)`                       |
  | COUNT | 统计一列中值的个数                     | `COUNT([DISTINCT | ALL] <列名>)` |
  | SUM   | 计算一列值的总和（此列必须为数值型）   | `SUM([DISTINCT | ALL] <列名>)`   |
  | AVG   | 计算一列值的平均值（此列必须为数值型） | `AVG([DISTINCT | ALL] <列名>)`   |
  | MAX   | 求一列中的最大值                       | `MAX([DISTINCT | ALL] <列名>)`   |
  | MIN   | 求一列中的最小值                       | `MIN([DISTINCT | ALL] <列名>)`   |
- GROUP BY 子句：细化聚集函数的作用对象
    - 按指定的一列或多列值分组，值相等的为一组
    - 如果未对查询结果分组，聚集函数将作用于整个查询结果；**对查询结果分组后，聚集函数将分别作用于每个组**
- HAVING 短语
    - 作用：对 GROUP BY 子句分组的后的组进行筛选
    - 依赖于 GROUP BY 子句，不能单独出现
    - 与 WHERE 子句的区别
        - 作用对象不同： WHERE 子句作用于基表或视图，从中选择满足条件的元组；HAVING 短语作用于组，从中选择满足条件的组
        - 聚合函数的使用：WHERE 子句中不能用聚集函数作为条件表达式；HAVING 短语可以

## 连接查询

**定义**：同时涉及两个以上的表的查询

**连接条件或连接谓词**：用来连接两个表的条件。
- 一般格式：
  ```
  [<表名 1>.]<列名 1> <比较运算符> [<表名 2>.]<列名 2>
  ```
  ```
  [<表名 1>.]<列名 1> BETWEEN [<表名 2>.]<列名 2> AND [<表名   2>.]<列名 3>
  ```

**连接字段**：连接谓词中的列名称
- 连接条件中的各连接字段类型必须是可比的，但名字不必相同
- 名字相同时需要使用 `<表名 | 表的别名>.` 来区分

**分类**：
- 等值连接（包括自然连接）与非等值连接
    - 嵌套循环法（NESTED-LOOP）
        > 1. 找到表 1 的第一个元组，然后从表 2 第一个元组起遍历到最后一个，如果表 1 和表 2 的当前的元组符合连接条件，将两个元组拼接并成结果表的一个元组
        > 2. 找到表 1 的下一个元组，继续顺序遍历表 2 的所以元组
        > 3. 重复上述操作，直到表 1 中的全部元组都处理完毕
    - 排序合并法（SORT-MERGE）：常用于 `=` 连接
        > 1. 将表 1 和表 2 的元组按连接字段升序排序
        > 2. 找到表 1 的第一个元组，然后从表 2 第一个元组起遍历到最后一个，如果表 1 和表 2 的当前的元组的连接字段相等，将两个元组拼接并成结果表的一个元组。如果表 2 当前元组连接字段 `>` 表 1 当前元组的连接字段，则停止遍历表 2
        > 3. 找到表 1 的下一个元组，继续顺序遍历表 2 的所以元组
        > 4. 重复上述操作，直到表 1 或表 2 中的全部元组都处理完毕
    - 索引连接（INDEX-JOIN）
        > 1. 对表 2 按连接字段建立索引
        > 2. 找到表 1 的第一个元组，根据表 1 连接字段获取表 2 连接字段，再使用表 2 连接字段依次查询表 2 的索引，从中找到满足条件的元组，将两个元组拼接并成结果表的一个元组
- 自身连接
    - 一个表与其自己进行连接
    - 需要给表起别名以示区别
    - 由于所有属性名都是同名属性，因此必须使用别名前缀
- 外连接
    - 普通连接操作只输出满足连接条件的元组
    - 外连接操作以指定表为连接主体，将主体表中不满足连接条件的元组一并输出
    - 左外连接：列出左边关系中所有的元组
    - 右外连接：列出右边关系中所有的元组
- 多表连接
    - 两个以上的表进行连接

## 嵌套查询

**嵌套查询概述：**
- 一个 SELECT-FROM-WHERE 语句称为一个查询块
- 将一个查询块嵌套在另一个查询块的 WHERE 子句或 HAVING 短语的条件中的查询称为嵌套查询
- 上层的查询块称为**外层查询或父查询**，下层查询块称为**内层查询或子查询**
- SQL 语言允许多层嵌套查询，即一个子查询中还可以嵌套其他子查询
- 子查询的限制：不能使用 ORDER BY 子句

**嵌套查询求解方法：**
- 不相关子查询：子查询的查询条件不依赖于父查询
    > - 由里向外，逐层处理
    > - 即每个子查询在上一级查询处理之前求解，子查询的结果用于建立其父查询的查找条件
- 相关子查询：子查询的查询条件依赖于父查询
    > - 首先取外层查询中表的第一个元组，根据它与内层查询相关的属性值处理内层查询，若 WHERE 子句返回值为真，则取此元组放入结果表
    > - 然后再取外层表的下一个元组
    > - 重复这一过程，直至外层表全部检查完为止

**分类：**
- 带有 `IN` 谓词的子查询：当子查询结果只有一个时可以使用 `=` 代替
- 带有比较运算符的子查询：`>`，`<`，`=`，`>=`，`<=`，`!=` 或 `<>`
- 带有 `ANY`（`SOME`）或 `ALL` 谓词的子查询
    - 需要与比较运算符连用
    - 可以使用聚合函数中的 `MIN` 和 `MAX` 代替

      |         | =   | <> 或 != | <     | <=     | >     | >=     |
      | ------- | --- | -------- | ----- | ------ | ----- | ------ |
      | **ANY** | IN  |          | < MAX | <= MAX | > MIN | >= MIN |
      | **ALL** |     | NOT IN   | < MIN | <= MIN | > MAX | >= MAX |
- 带有 `EXISTS` 谓词的子查询
    - 代表 存在量词 $\exists$
    - 带有 `EXISTS` 谓词的子查询不返回任何数据，只产生逻辑真值 `true` 或逻辑假值 `false`
        - 若内层查询结果非空，则外层的 WHERE 子句返回真值
        - 若内层查询结果为空，则外层的 WHERE 子句返回假值
    - 由 `EXISTS` 引出的子查询，其目标列表达式通常都用 `*` ，因为子查询只返回真值或假值，给出列名无实际意义

## 集合查询

- 集合操作的种类
    - 并操作 `UNION`
        - `UNION`：将多个查询结果合并起来时，系统自动去掉重复元组
        - `UNION ALL`：将多个查询结果合并起来时，保留重复元组
    - 交操作 `INTERSECT`
    - 差操作 `EXCEPT`
- 参加集合操作的各查询结果的列数必须相同，对应项的数据类型也必须相同

## 基于派生表的查询

- 子查询不仅可以出现在 WHERE 子句中，还可以出现在 FROM 子句中，这时子查询生成的临时派生表（Derived Table）成为主查询的查询对象
- 如果子查询中没有聚集函数，派生表可以不指定属性列，子查询 SELECT 子句后面的列名为其缺省属性。

# 数据更新

## 插入数据

### 插入元组

```
INSERT
  INTO <表名> [(<属性列 1> [, <属性列 2> ...)]
  VALUES (<常量 1> [, <常量 2>]...);
```
> - 将新元组插入指定表中
> - INTO 子句
>     - 没有指定属性列：表示要插入的是一条完整的元组，且属性列属性与表定义中的顺序一致
>     - 指定部分属性列：插入的元组在其余属性列上取空值
>     - 指定要插入数据的表名及属性列，属性列的顺序可与表定义中的顺序不一致
> - VALUES 子句：提供的值必须与 INTO 子句匹配（值的个数、类型）

### 插入子查询结果

```
INSERT
    INTO <表名> [(<属性列 1> [, <属性列 2> ...)]
    <子查询>;
```
> - 子查询：SELECT 子句目标列必须与 INTO 子句匹配（值的个数、类型）
> - 关系数据库管理系统在执行插入语句时会检查所插元组是否破坏表上已定义的完整性规则
>     - 实体完整性
>     - 参照完整性
>     - 用户定义的完整性
>         - `NOT NULL` 约束
>         - `UNIQUE` 约束
>         - 值域约束

## 修改数据

```
UPDATE <表名>
    SET <列名> = <表达式> [, <列名> = <表达式>]...
    [WHERE <条件>];
```
> - 功能：修改指定表中满足 WHERE 子句条件的元组
> - SET 子句给出 <表达式> 的值用于取代相应的属性列
> - WHERE 子句
>     - 指定要修改的元组
>     - 条件中可以使用 SELECT 子查询（与 IN 等连用）
>     - 如果省略 WHERE 子句，表示要修改表中的所有元组
> - 关系数据库管理系统在执行修改语句时会检查修改操作是否破坏表上已定义的完整性规则
>     - 实体完整性
>     - 主码不允许修改
>     - 用户定义的完整性
>         - `NOT NULL` 约束
>         - `UNIQUE` 约束
>         - 值域约束

## 删除数据

```
DELETE
    FROM <表名>
    [WHERE <条件>];
```
> - 功能删除指定表中满足 WHERE 子句条件的元组
> - WHERE 子句
>     - 指定要删除的元组（与 IN 等连用）
>     - 缺省表示要删除表中的全部元组，表的定义仍在字典中
>     - 条件中可以使用 SELECT 子查询

# 空值处理

**空值：**
- 空值就是“不知道”或“不存在”或“无意义”的值
- 一般有以下几种情况
    - 该属性应该有一个值，但目前不知道它的具体值
    - 该属性不应该有值
    - 由于某种原因不便于填写
- 空值是一个很特殊的值，含有不确定性。对关系运算带来特殊的问题，需要做特殊的处理

**空值的判断**：判断一个属性的值是否为空值，用 `IS NULL` 或 `IS NOT NULL` 来表示

**空值的约束条件**:
- 属性定义（或者域定义）中
    - 有 `NOT NULL` 约束条件的不能取空值
    - 加了 `UNIQUE` 限制的属性不能取空值
    - 码属性不能取空值

**空值的算术运算、比较运算和逻辑运算**:
- 空值与另一个值（包括另一个空值）的算术运算的结果为空值
- 空值与另一个值（包括另一个空值）的比较运算的结果为 UNKNOWN
- 有 `UNKNOWN` 后，传统二值（`TRUE`，`FALSE`）逻辑就扩展成了三值逻辑
  |   x   |   y   | x AND y | x OR y | `NOT` x |
  | :---: | :---: | :-----: | :----: | :-----: |
  |   T   |   O   |    O    |   T    |    F    |
  |   F   |   O   |    F    |   O    |    T    |
  |   U   |   U   |    U    |   U    |    U    |
  - T = `TRUE`; U = `UNKOWN`; F = `FALSE`; O = `TRUE`、`UNKOWN、`FALSE` 中任一个

# 视图

**视图的特点**：
- 虚表，是从一个或几个基本表（或视图）导出的表
- 只存放视图的定义，不存放视图对应的数据
- 基表中的数据发生变化，从视图中查询出的数据也随之改变

## 定义

```
CREATE VIEW <视图名> [(<列名> [, <列名>]...)]
    AS <子查询> [WITH CHECK OPTION];
```
> - 组成视图的属性列名：全部省略或全部指定
>     - 全部省略：由子查询的目标列中的各个字段组成
>     - 明确指定视图的所有列名:
>         - 某个目标列是聚集函数或列表达式
>         - 多表连接时选出了几个同名列作为视图的字段
>         - 需要在视图中为某个列启用新的更合适的名字
> - 子查询
>     - 可以是任意的 SELECT 语句（包括单表、多表查询）
>     - 是否可以含有 ORDER BY 子句和 DISTINCT 短语，则决定具体系统的实现
>     - 关系数据库管理系统执行 CREATE VIEW 语句时只是把视图定义存入数据字典，并不执行子查询
>     - 在对视图查询时，按视图的定义从基本表中将数据查出（执行子查询）
> - WITH CHECK OPTION：
>     - 对视图进行 `UPDATE`，`INSERT` 和 `DELETE` 操作时要保证更新、插入或删除的行满足视图定义中的谓词条件
>     - 谓词条件就是子查询中 WHERE 子句的条件表达式
> - 若一个视图是从单个基本表导出的，并且只是去掉了基本表的某些行和某些列，但保留了主码，我们称这类视图为**行列子集视图**

## 删除

```
DROP VIEW <视图名> [CASCADE];
```
> - 该语句从数据字典中删除指定的视图定义
> - 如果该视图上还导出了其他视图，使用 CASCADE 级联删除语句，把该视图和由它导出的所有视图一起删除
> - 删除基表时，由该基表导出的所有视图定义都必须显式地使用 DROP VIEW 语句删除

## 查询

- 用户角度：查询视图与查询基本表相同
- 关系数据库管理系统实现视图查询的方法：视图消解法（View Resolution）
    - 进行有效性检查
    - 转换成等价的对基本表的查询
    - 执行修正后的查询
    - 局限：有些情况下，视图消解法不能生成正确的查询

## 更新

- 更新视图的限制：一些视图是不可更新的，因为对这些视图的更新不能唯一地有意义地转换成对相应基本表的更新
- 允许对行列子集视图进行更新，对其他类型视图的更新不同系统有不同限制
- DB2 对视图更新的限制：
    - 若视图是由两个以上基本表导出的，则此视图不允许更新。
    - 若视图的字段来自字段表达式或常数，则不允许对此视图执行 `INSERT` 和 `UPDATE` 操作，但允许执行 `DELETE` 操作。
    - 若视图的字段来自集函数，则此视图不允许更新。
    - 若视图定义中含有 `GROUP BY` 子句，则此视图不允许更新。
    - 若视图定义中含有 `DISTINCT` 短语，则此视图不允许更新。
    - 若视图定义中有嵌套查询，并且内层查询的 `FROM` 子句中涉及的表也是导出该视图的基本表，则此视图不允许更新。

## 视图的作用

- 能够简化用户的操作
  > 当视图中数据不是直接来自基本表时，定义视图能够简化用户的操作
  > - 基于多张表连接形成的视图
  > - 基于复杂嵌套查询的视图
  > - 含导出属性的视图
- 使用户能以多种角度看待同一数据
  > 视图机制能使不同用户以不同方式看待同一数据，适应数据库共享的需要
- 对重构数据库提供了一定程度的逻辑独立性
  > - 数据库重构：使用户的外模式保持不变，用户的应用程序通过视图仍然能够查找数据
  > - 视图只能在一定程度上提供数据的逻辑独立性：由于对视图的更新是有条件的，因此应用程序中修改数据的语句可能仍会因基本表结构的改变而改变。
- 能够对机密数据提供安全保护
  > 对不同用户定义不同视图，使每个用户只能看到他有权看到的数据
- 适当的利用视图可以更清晰的表达查询
  > 经常需要执行这样的查询“对每个同学找出他获得最高成绩的课程号”
  > - 可以先定义一个视图，求出每个同学获得的最高成绩
  > - 然后通过连接改视图课程基本表查询结果