# Bitmap

Redis Bitmap通过类似数组结构存放0或1（bit位）作为值。底层结构是Redis String，即将字符串当作是Bitmap来操作。

## 相关命令

### `SETBIT`

```redis
SETBIT key offset bit-value
```

设置或者清空key对应的字符串值在offset处的bit值。bit-value只能是0或1。

当key不存在的时候，就创建一个新的字符串，当key对应的字符串长度不足时会在后面补0，以确保这个字符串大到在offset处有bit值。参数offset需要大于等于0，并且小于2^32（限制bitmap大小为512M）。

注意：当设置最后一个bit（offset等于2^32 - 1）并且key还没有一个字符串值或者其字符串值长度不足，Redis需要立即分配所有内存，这有可能会导致服务阻塞一会。一旦第一次内存分配完，后面对同一个key调用`SETBIT`就不会再内存分配。

### `GETBIT`

```redis
GETBIT key offset
```

返回key对应的字符串值在offset处的bit值。

当offset超出了字符串长度的时候，这个字符串就被假定为由0比特填充的连续空间。当key不存在的时候，它就认为是一个空字符串，所以offset总是超出范围，然后value也被认为是由0比特填充的连续空间。

### `BITCOUNT`

```redis
BITCOUNT key [start end]
```

统计字符串被设置为1的bit数。

默认对整个字符串进行计数，可以通过指定start和end参数只在指定bit范围内计数。start和end参数的设置和`GETRANGE`命令类似，都可以使用负数值，比如-1表示最后一个位，而-2表示倒数第二个位，以此类推。

不存在的key被当成是空字符串来处理，因此对一个不存在的key进行`BITCOUNT`操作，结果为0。

### `BITOP`

```redis
BITOP operation dest-key key [key ...]
```

对一个或多个保存二进制位的字符串key进行位元操作，并将结果保存到dest-key上。

operation参数：

| 参数 | 说明                        |
| ---- | --------------------------- |
| `AND`  | 与                          |
| `OR`   | 或                          |
| `XOR`  | 异或                        |
| `NOT`  | 非，只能对一个key进行操作 |

处理不同长度的字符串：集合中所有比最长字符串短的字符串在尾部补0至最长字符串的长度。不存在的key的字符串值当作空字符串，然后进行补0。

### `BITPOS`

```redis
BITPOS key bit-value [start] [end]
```

返回字符串里面第一个被设置为bit-value的bit位。

默认情况下整个字符串都会被检索一次，只有在指定start和end参数（包括start和end位），该范围被解释为一个**byte**的范围，而不是bit的范围。所以start=0并且end=2是指前3个byte范围内（即0~23的bit范围内）查找。

注意，返回的位的位置始终是从0开始的（绝对位置），即使使用了start来指定了一个开始字节也是这样。

和`GETRANGE`命令一样，start和end也可以包含负值，负值将从字符串的末尾开始计算，-1是字符串的最后一个byte，-2是倒数第二个，等等。

不存在的key将会被当做空字符串来处理。

返回值：

- 命令返回字符串里面第一个被设置为bit-value的bit位。
- 如果我们在空字符串或者0字节的字符串里面查找bit为1的内容，那么结果将返回-1。
- 如果我们在字符串里面查找bit为0而且字符串只包含1的值时，将返回字符串最右边的第一个空位。如果有一个字符串是三个字节的值为0xff的字符串，那么命令`BITPOS key 0`将会返回24，因为0~23位都是1。
- **基本上，可以把字符串看成右边有无数个0**。然而，如果用指定start和end范围进行查找指定值时，如果该范围内没有对应值，结果将返回-1。

### `BITFIELD`

```redis
BITFIELD key [GET type offset]
             [SET type offset value]
             [INCRBY type offset increment] [OVERFLOW WRAP|SAT|FAIL]
```

本命令会把Redis字符串当作bit数组，并能对变长位宽和任意未字节对齐的指定整型位域进行寻址。

在实践中，可以使用该命令对一个有符号的5位整型数（i5）的1234位设置指定值，也可以对一个31位无符号整型数（u31）的4567位进行取值。类似地，在对指定的整数进行自增和自减操作，本命令可以提供有保证的、可配置的上溢和下溢处理操作。'

`BITFIELD`命令能操作多字节位域，它会执行一系列操作，并返回一个响应数组，在参数列表中每个响应数组匹配相应的操作。

例如，下面的命令是对一个8位有符号整数偏移100位自增1，并获取4位无符号整数的值：

```redis
> BITFIELD mykey INCRBY i8 100 1 GET u4 0
1) (integer) 1
2) (integer) 0
```

提示：

- 用`GET`指令对超出当前字符串长度的bit（含key不存在的情况）进行寻址，执行操作的结果会对缺失部分的bits赋值为0。
- 用`SET`或`INCRBY`指令对超出当前字符串长度的位（含key不存在的情况）进行寻址，将会扩展字符串并对扩展部分进行补0，扩展方式包括：按需扩展、按最小长度扩展和按最大寻址能力扩展。

支持子命令和整型：

| 子命令                               | 说明                                           |
| ------------------------------------ | ---------------------------------------------- |
| `GET <type> <offset>`                | 返回指定的位域                                 |
| `SET <type> <offset> <value>`        | 设置指定位域的值并返回它的原值                 |
| `INCRBY <type> <offset> <increment>` | 自增指定位域的值并返回它的新值                 |
| `OVERFLOW [WRAP\|SAT\|FAIL]`         | 设置溢出行为来改变调用`INCRBY`指令的后序操作 |

type：

- 当需要一个整型时，有符号整型需在位数前加`i`，无符号在位数前加`u`。例如，`u8`是一个8位的无符号整型，`i16`是一个16位的有符号整型。
- 有符号整型最大支持64位，而无符号整型最大支持63位。对无符号整型的限制，是由于当前Redis协议不能在响应消息中返回64位无符号整数。

offset：

- 如果未定带数字的前缀，将会以字符串的第0位作为起始位。
- 不过，如果偏移量带有`#`前缀，那么指定的偏移量需要乘以整型宽度，如`i8 #2`表示8 * 2 = 16位。

溢出控制：

- `WRAP`（默认）：回环算法，适用于有符号和无符号整型两种类型。对于无符号整型，回环计数将对整型最大值进行取模操作（C语言的标准行为）。对于有符号整型，上溢从最负的负数开始取数，下溢则从最大的正数开始取数，例如，如果`i8`整型的值设为127，自加1后的值变为-128。
- `SAT`：饱和算法，下溢之后设为最小的整型值，上溢之后设为最大的整数值。例如，i8整型的值从120开始加10后，结果是127，继续增加，结果还是保持为127。下溢也是同理，但量结果值将会保持在最负的负数值。
- `FAIL`：失败算法，这种模式下，在检测到上溢或下溢时，不做任何操作。相应的返回值会设为NULL，并返回给调用者。
