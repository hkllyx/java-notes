# Stream

Redis Stream是Redis 5.0新增加的数据结构。

Redis Stream主要用于消息队列（MQ，Message Queue），Redis本身是有一个Redis发布订阅 （pub/sub）来实现消息队列的功能，但它有个缺点就是消息无法持久化，如果出现网络断开、Redis宕机等，消息就会被丢弃。简单来说Redis发布订阅可以分发消息，但无法记录历史消息。

而Redis Stream提供了消息的持久化和主备复制功能，可以让任何客户端访问任何时刻的数据，并且能记住每一个客户端的访问位置，还能保证消息不丢失。

Redis Stream的结构如下所示，它有一个消息链表，将所有加入的消息都串起来，每个消息都有一个唯一的ID和对应的内容：

![Redis Stream](../../../../resource/img/Redis/Redis%20Stream.png)

每个Stream都有唯一的名称，它就是Redis的key，在我们首次使用`XADD`指令追加消息时自动创建。

- Consumer：消费者，消费Stream中的消息
- Consumer Group：消费组，使用`XGROUP CREATE`命令创建，一个消费组有多个消费者（Consumer）
- Last_delivered_id：游标，每个消费组会有个游标Last_delivered_id，组内任意一个消费者读取了消息都会使游标Last_delivered_id往前移动。
- Pending_ids：消费者的状态变量，作用是维护消费者的未确认的id。Pending_ids记录了当前已经被客户端读取但是还没有确认（Ack，Acknowledge character）的消息。也对应后文中的待处理条目列表（pending entries list，PEL）

## 相关命令

### `XADD`

```redis
XADD key [NOMKSTREAM] [MAXLEN | MINID [= | ~] threshold
    [LIMIT count]]
    * | id
    field value [ field value ...]
```

将指定的Stream条目（Entry）追加到指定key的Stream中。如果key不存在，会自动预先创建一个Stream然后追加，可以使用`NOMKSTREAM`选项关闭自动创建Stream的功能。

`XADD`是唯一可以向Stream添加数据的Redis命令，但是还有其他命令，例如`XDEL`和`XTRIM`能够从Stream中删除数据。

一个Stream条目是由一组键值对组成的，它基本上是一个小的字典。键值对以用户给定的顺序存储，并且读取Stream的命令（如`XRANGE`或者`XREAD`）可以保证按照通过`XADD`添加的顺序返回。

Stream条目的ID标识Stream内唯一的条目。如果指定的ID参数是`*`，`XADD`命令会自动生成一个唯一的ID。但是，也可以指定一个良好格式的ID，以便新的条目以指定的ID准确存储，虽然仅在极少数情况下有用。

良好的ID是由`-`隔开的两个数字组成的，例如，`1526919030474-55`。两个部分数字都是64位的，当自动生成ID时，第一部分是生成ID的Redis实例的毫秒格式的Unix时间。第二部分只是一个序列号，以及是用来区分同一毫秒内生成的ID的。

ID保证始终是递增的：如果比较刚插入的条目的ID，它将大于其他任何过去的ID，因此条目在Stream中始终是排序的。为了保证这个特性，如果Stream中当前最大的ID的时间大于实例的当前本地时间（例如，再本地始终回调了，或者在故障转移之后新主机具有不同的绝对时间，则可能发生这种情况），将会使用前者，并将ID的序列部分递增。

当用户为`XADD`命令指定显式ID时，最小有效的ID是`0-1`，并且用户必须指定一个比当前Stream中的任何ID都要大的ID，否则命令将失败。通常使用特定ID仅在您有另一个系统生成唯一ID（例如SQL表），并且您确实希望Redis Stream ID与该另一个系统的ID匹配时才有用。

`XADD`也包含`XTRIM`的功能，它可以保证每次向Stream添加条目后保持Stream的大小不变，从而有效得限流。虽然Redis Stream支持精准，默认也是精确的限制Stream大小，但由于内部的表现方式是的近似限制是更加有效的。

### `XCLAIM`

```redis
XCLAIM key group consumer min-idle-time ID [ID ...]
    [IDLE ms] [TIME ms-unix-time]
    [RETRYCOUNT count] [FORCE] [JUSTID]
```

在Stream的消费者组上下文中，此命令改变待处理消息的所有权，新的所有者是在命令参数中指定的消费者。

通常发生在这种情形下的：有一个具有关联消费者组的Stream，消费者A在消费者组的上下文中通过`XREADGROUP`从流中读取一条消息，读取消息时随之在消费者组的PEL（待处理条目列表）中创建了一个待处理消息条目，这意味着这条消息已传递给给定的消费者，但是尚未通过`XACK`确认。突然这个消费者出现故障，且永远无法恢复。其他消费者可以使用`XPENDING`检查已经过时很长时间的待处理消息列表，为了继续处理这些消息，他们使用`XCLAIM`来获得消息的所有权，并继续处理。

请注意，消息只有在其空闲时间大于我们通过`XCLAIM`指定的空闲时间的时才会被认领。因为`XCLAIM`也会重置消息的空闲时间（因为这是处理消息的一次新尝试），两个试图同时认领消息的消费者将永远不会成功，即只可能有一个消费者能成功认领消息。这避免了我们用微不足道的方式多次处理给定的消息（虽然一般情况下无法完全避免多次处理）。

此外，`XCLAIM`会增加消息的尝试交付次数。通过这种方式，由于某些原因而无法处理的消息（例如因为消费者在尝试处理期间崩溃），将开始具有更大的计数器，并可以在系统内部被检测到。

该命令有多个选项，但是大部分主要用于内部使用，以便将`XCLAIM`或其他命令的结果传递到AOF文件，以及传递相同的结果到从节点，并且不太可能对普通用户有用：

| 选项                | 说明                                                                                                                                                                                                                      |
| ------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `IDLE ms`           | 设置消息的空闲时间（自最后一次交付到目前的时间）。省缺值为0，即时间计数被重置，因为消息现在有新的所有者来尝试处理它                                                                                                       |
| `TIME ms-unix-time` | 与`IDLE`相同，但它不是设置相对的毫秒数，而是将空闲时间设置为一个指定的Unix时间（以毫秒为单位）。这对于重写生成`XCLAIM`命令的AOF文件很有用                                                                                 |
| `RETRYCOUNT count`  | 将重试计数器设置为指定的值。这个计数器在每一次消息被交付的时候递增。通常，`XCLAIM` 不会更改这个计数器，它只在调用`XPENDING`命令时提供给客户端：这样客户端可以检测到异常，例如在大量传递尝试后由于某种原因从未处理过的消息 |
| `FORCE`             | 在PEL中创建待处理消息条目，即使某些指定的ID尚未在分配给不同客户端的PEL中。但是消息必须存在于流中，否则不存在的消息ID将会被忽略                                                                                            |
| `JUSTID`            | 只返回成功认领的消息ID数组，不返回实际的消息                                                                                                                                                                              |

### `XAUTOCLAIM`

### `XACK`

```redis
XACK key group ID [ID ...]
```

用于从Stream的消费者组的PEL（待处理条目列表）中删除一条或多条消息。

当一条消息交付到某个消费者时，它将被存储在PEL中等待处理。通常发生在调用`XREADGROUP`命令，或者通过调用`XCLAIM`命令让一个消费者接管消息的时候发生。

待处理消息被交付到某些消费者，但是服务器尚不确定它是否至少被处理了一次。因此对新调用`XREADGROUP`来获取消费者的消息历史记录（比如用0作为ID）将返回此类消息。类似地，待处理的消息将由检查PEL的`XPENDING`命令列出。

一旦消费者成功地处理完一条消息，应该调用`XACK`确认它，这样这个消息就不会被再次处理，且关于此消息的PEL条目也随之被清除，从Redis服务器释放内存。

该命令返回成功确认的消息数。某些消息ID可能不再是PEL的一部分（例如，它们已经被确认），而且`XACK`不会把他们算到成功确认的数量中。

### `XDEL`

```redis
XDEL key ID [ID ...]
```

从指定Stream中移除指定的条目，并返回成功删除的条目的数量，在传递的ID不存在的情况下，返回的数量可能与传递的ID数量不同。

通常，可以Redis Stream想象为一个仅支持附加（append-only）的数据结构，但是Redis Steam是存在于内存中的，所以我们也可以删除条目。这也许会有用，例如，为了遵守特定的隐私策略。

理解删除条目的底层细节：

Redis Stream以一种内存高效的方式表示：使用基数树（radix tree）来索引包含线性数十个Stream条目的宏节点。通常，当你从Stream中删除一个条目的时候，条目并没有真正被驱逐，只是被标记为删除。

最终，如果宏节点中的所有条目都被标记为删除，则会销毁整个节点，并回收内存。这意味着如果你从Stream里删除大量的条目，比如超过50%的条目，则每一个条目的内存占用可能会增加，因为Stream将会开始变得碎片化。然而，Stream的性能将保持不变。

在Redis未来的版本中，当一个宏节点内删除条目达到一定数量的时候，我们有可能会触发节点垃圾回收机制。目前，根据我们对这种数据结构的预期用途，还不太适合增加这样的复杂度。

### `XGROUP`

该命令用于管理Stream关联的消费者组。使用`XGROUP`可以完成一下四件事。

#### `XGROUP CREATE`

```redis
XGROUP CREATE key group-name id
```

创建与Stream关联的新消费者组。最后一个参数id是要考虑已传递的流中最后一项的ID。

使用`$`表示流中最后一项的ID，在这种情况下，从该消费者组获取数据的消费者只能看到到达流的新元素。
- 如果指定的消费者组已经存在，则该命令将返回BUSYGROUP错误。否则将执行该操作并返回OK。
- 可以为给定的流关联无限多的消费者组，没有硬性限制。

#### XGROUP DESTROY

```redis
XGROUP DESTROY key group-name
```

- 即使存在活动的消费者和待处理消息，消费者组也将被销毁，因此请确保仅在真正需要时才调用此命令。

#### XGROUP DELCONSUMER

```redis
XGROUP DELCONSUMER key group-name consumer-name
```

- 从消费者组中移除指定的消费者。
- 每当某个命令提到新的消费者名称时，就会自动创建消费者组中的消费者。
- 但有时候删除旧的消费者可能会有用，因为他们已经不再使用。
- 命令返回消费者在被删除之前所拥有的待处理消息数量。

#### XGROUP SETID

```redis
XGROUP SETID key id
```

- 设置将消费者组的最后交付ID，即下一条要传递的消息。
- 通常情况下，在消费者创建时设置下一个ID（作为`XGROUP CREATE`的最后一个参数）。但是使用这种形式，可以在以后修改下一个ID，而无需再次删除和创建使用者组。
- 例如，如果你希望消费者组中的消费者重新处理流中的所有消息，你可能希望将其下一个ID设置为0。
- 可以使用 "$" 字符表示最后一项的ID

### `XINFO`

这是一个内省命令，用于检索关于流和关联的消费者组的不同的信息。有三种可能的形式：

#### XINFO STREAM

```redis
XINFO STREAM key
```

- 返回有关存储在特定键的流的一般信息。
- 报告的信息：
  - 流的元素的数量
  - 有关表示流的基数树的详细信息（主要用于优化和调试任务）
  - 与流关联的消费者组的数量
  - 最后生成的ID（某些条目被删除时，此ID可能与最后一个条目的ID不同）
  - 最后显示了流中完整的第一个和最后一个条目，以便了解流的内容是什么

#### XINFO GROUPS

```redis
XINFO GROUPS key
```

- 只获得与流关联的所有消费者组的输出。
- 对每一个列出的消费者组，该命令还显示该组中已知的消费者数量，以及该组中的待处理消息（已传递但尚未确认）数量。

#### XINFO CONSUMERS

```redis
XINFO CONSUMERS key group-name
```

- 取得指定消费者组中的消费者列表。
- 这个消费者的空闲毫秒时间（最后一个字段）以及消费者名称和待处理消息数量。

请注意，你不应该依赖字段的确切位置，也不应该依赖字段的数量，因为将来可能会增加新的字段。因此，表现良好的客户端应该获取整个列表，并将其报告给用户，例如，作为字典数据结构。低级客户端（例如C客户端，其中项目可能以线性数组报告）应该注明顺序是不确定的。

### `XLEN`

```redis
XLEN key
```

- 返回流中的条目数。如果指定的key不存在，则此命令返回0，就好像该流为空。但是请注意，与其他的Redis类型不同，零长度流是可能的，所以你应该调用`TYPE`或者`EXISTS`来检查一个key是否存在。
- 一旦内部没有任何的条目（例如调用`XDEL`后），流不会被自动删除，因为可能还存在与其相关联的消费者组。

### `XPENDING`

```redis
XPENDING key group [start end count] [consumer]
```

- 通过消费者组从流中获取数据，而不是确认这些数据，具有创建待处理条目的效果。这在`XREADGROUP`命令中已有详尽的说明，在我们的Redis Streams介绍中更好。`XACK` 命令会立即从待处理条目列表（PEL）中移除待处理条目，因为一旦消息被成功处理，消费者组就不再需要跟踪它并记住消息的当前所有者。
- `XPENDING` 命令是检查待处理消息列表的接口，因此它是一个非常重要的命令，用于观察和了解消费者组正在发生的事情：哪些客户端是活跃的，哪些消息在等待消费，或者查看是否有空闲的消息。此外，该命令与`XCLAIM`一起使用，用于实现长时间故障的消费者的恢复，因此不处理某些消息：不同的消费者可以认领该消息并继续处理。这在Redis Streams介绍和`XCLAIM`命令页面中有更好的解释，这里不再介绍。

### XRANGE, XREVRANGE

```redis
XRANGE key start end [COUNT count]
```

- 返回流中满足给定ID范围的条目。范围由最小和最大ID指定。所有ID在指定的两个ID之间或与其中一个ID相等（闭合区间）的条目将会被返回。
- `XRANGE` 命令有许多用途：
  - 返回特定时间范围的项目。这是可能的，因为流的ID与时间相关。
  - 增量迭代流，每次迭代只返回几个项目。但它在语义上比`SCAN`函数族强大很多。
  - 从流中获取单个条目，提供要获取两次的条目的ID：作为查询间隔的开始和结束。
- 特殊ID："-" 和 "+" 分别表示流中可能的最小ID和最大ID。

```redis
XREVRANGE key end start [COUNT count]
```

- 此命令与`XRANGE`完全相同，但显著的区别是以相反的顺序返回条目，并以相反的顺序获取开始~结束参数。

### XREAD, XREADGROUP

```redis
XREAD [COUNT count] [BLOCK milliseconds]
    STREAMS key [key ...] ID [ID ...]
```

- 从一个或者多个流中读取数据，仅返回ID大于调用者报告的最后接收ID的条目。
- 此命令有一个BLOCK选项，用于等待可用的项目，类似于`BRPOP`或者`BZPOPMIN`等等。
- 如果未提供BLOCK选项，此命令是同步的，并可以认为与`XRANGE`有些相关：它将会返回流中的一系列项目，但与`XRANGE`相比它有两个基本差异（如果我们只考虑同步使用）：
  - 如果我们想要从多个键同时读取，则可以使用多个流调用此命令。这是`XREAD`的一个关键特性，因为特别是在使用`BLOCK`进行阻塞时，能够通过单个连接监听多个键是一个至关重要的特性。
  - `XRANGE` 返回一组ID中的项目，`XREAD` 更适合用于从第一个条目（比我们到目前为止看到的任何其他条目都要大）开始使用流。因此，对于每个流我们传递给`XREAD`的是从该流接收的最后一个条目的ID。
  - 例如，如果我有两个流mystream和writers，并且我希望同时从这两个流中读取数据（从它们的第一个元素开始），我可以像下面这样调用XREAD：

        ```
        XREAD COUNT 2 STREAMS mystream writers 0-0 0-0
        ```

        请注意：我们在例子中使用了COUNT选项，因此对于每一个流，调用将返回每个流最多两个元素。
- STREAMS选项是强制的，并且必须是最后一个选项。
- 使用不完整的ID是有效的，就像它对`XRANGE`一样有效。但是这里ID的序列号部分，如果缺少，将总是被解释为0，所以以下命令等效：

    ```
    XREAD COUNT 2 STREAMS mystream writers 0 0
    XREAD COUNT 2 STREAMS mystream writers 0-0 0-0
    ```

- 特殊的ID "$"：有时阻塞我们只希望接收从我们阻塞的那一刻开始通过XADD添加到流的条目。在这种情况下，我们对已经添加条目的历史不感兴趣。
- 详见 [XREAD](http://redis.cn/commands/xread.html)

```redis
XREADGROUP GROUP group consumer [COUNT count]
    [BLOCK milliseconds] STREAMS key [key ...] ID [ID ...]
```

- `XREADGROUP` 命令是`XREAD`命令的特殊版本，支持消费者组。

### `XTRIM`

```redis
XTRIM key MAXLEN [~] count
```

- 将流裁剪为指定数量的项目，如有需要，将驱逐旧的项目（ID较小的项目）。
- 此命令被设想为接受多种修整策略，但目前只实现了一种，即`MAXLEN`，并且与 `XADD`中的`MAXLEN`选项完全相同。
