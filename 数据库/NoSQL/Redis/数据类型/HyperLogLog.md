# HyperLogLog

Redis HyperLogLog是用来做基数统计的算法的概率数据结构。

HyperLogLog的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。

在Redis里面，每个HyperLogLog键只需要花费12KB内存，就可以计算接近2^64个不同元素的基数。这和用Set计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。

但是，因为HyperLogLog只会根据输入元素来计算基数，而不会储存输入元素本身，所以HyperLogLog不能像集合那样，返回输入的各个元素。

## 基数计数

**基数计数**（cardinality counting）：通常用来统计一个集合中不重复的元素个数。例如用来统计某个网站的UV，或者用户搜索网站的关键词数量。

数据分析、网络监控及数据库优化等领域都会涉及到基数计数的需求。

大数据量背景下，要实现基数计数，首先需要确定存储统计数据的方案，以及如何根据存储的数据计算基数值；

另外还有一些场景下需要融合多个独立统计的基数值，例如对一个网站分别统计了三天的UV，现在需要知道这三天的UV总量是多少，怎么融合多个统计值。

## 基数计数方法

### 集合去重

是实现基数计数最简单的做法。保存一个集合，新增一个元素时检查这个集合是否已包含该元素，如果不包含则加入该元素，否则不加入。计数值就是集合的元素数量。

这种做法存在两个问题：

- 当统计的数据量变大时，相应的存储内存也会线性增长
- 当集合变大，判断其是否包含新加入元素的成本变大

### B-Tree

B树最大的优势是插入和查找效率很高（时间效率为$O(log_2N)$），如果用B树存储要统计的数据，可以快速判断新来的数据是否已经存在，并快速将元素插入B树。要计算基数值，只需要计算B树的节点个数。

但B-Tree仍不能解决内存线性增长的问题。

### Bitmap

Bitmap可以理解为通过一个bit数组来存储特定数据的一种数据结构，每一个bit位都能独立包含信息，bit是数据的最小存储单位，因此能大量节省空间，也可以将整个bit数据一次性load到内存计算。

如果要统计1亿个数据的基数值，大约需要内存：100000000 / 8 / 1024 / 1024 ≈ 12M，内存减少占用的效果显著。然而统计一个对象的基数值需要12M，如果统计10000个对象，就需要将近120G，同样不能广泛用于大数据场景。

### 概率算法

实际上，目前还没有发现更好的在大数据场景中准确计算基数的高效算法，因此在不追求绝对准确的情况下，使用概率算法算是一个不错的解决方案。

概率算法不直接存储数据集合本身，通过一定的概率统计方法预估基数值，这种方法可以大大节省内存，同时保证误差控制在一定范围内。目前用于基数计数的概率算法包括:

- Linear Counting（LC）：早期的基数估计算法，LC在空间复杂度方面并不算优秀，实际上LC的空间复杂度与上文中简单Bitmap方法是一样的（但是有个常数项级别的降低），都是$O(n_{max})$
- LogLog Counting（LLC）：相比于LC更加节省内存，空间复杂度只有$O(log_2(log_2(n_{max})))$
- HyperLogLog Counting（HLL）：基于LLC的优化和改进，在同样空间复杂度情况下，能够比LLC的基数估计误差更小

## HLL在Redis中的应用（命令）

### `PFADD`

```redis
PFADD key element [element ...]
```

将元素添加到key的HyperLogLog结构中。

如果一个HyperLogLog估计的近似基数在添加元素后发生改边则返回1，否则返回0。

如果指定的key不存在，这个命令会自动创建一个空的HyperLogLog结构（指定长度和编码的字符串）。

如果在调用该命令时仅提供key而不指定element也是可以的，如果这个key存在，则不会有任何操作，如果不存在，则会创建一个数据结构并返回1。

### `PFCOUNT`

```redis
PFCOUNT key [key ...]
```

当参数为一个key时，返回存储在HyperLogLog结构体的该变量的近似基数，如果该key不存在，则返回0。

当参数为多个key时，返回这些HyperLogLog并集的近似基数，这个值是将所给定的所有key的HyperLoglog结构合并到一个临时的HyperLogLog结构中计算而得到的。

HyperLogLog可以使用固定且很少的内存（每个HyperLogLog结构需要12K字节再加上key本身的几个字节）来存储集合的唯一元素。返回的可见集合基数并不是精确值，而是一个带有0.81%标准错误（standard error）的近似值。

例如为了记录一天会执行多少次各不相同的搜索查询，一个程序可以在每次执行搜索查询时调用一次`PFADD`，并通过调用`PFCOUNT`命令来获取这个记录的近似结果。

注意：这个命令的一个副作用是可能会导致HyperLogLog内部被更改，出于缓存的目的，它会用8字节来记录最近一次计算得到基数，**所以`PFCOUNT`命令在技术上是个写命令**。

### `PFMERGE`

```redis
PFMERGE destkey sourcekey [sourcekey ...]
```

将多个HyperLogLog合并为一个HyperLogLog，合并后的HyperLogLog的基数接近于所有HyperLogLog的可见集合（observed set）的并集。

合并得出的HyperLogLog会被储存在目标变量（第一个参数）里面，如果该key并不存在，那么命令在执行之前，会先为该键创建一个空的HyperLogLog。
