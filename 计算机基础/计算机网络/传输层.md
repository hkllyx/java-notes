# 运输层

## 进程之间的通信

![进程之间的通信](../../resource/img/计算机网络/032.png)

- 两个主机进行通信实际上就是两个主机中的应用进程互相通信。
- 应用进程之间的通信又称为端到端的通信。
- 运输层的一个很重要的功能就是复用和分用。应用层不同进程的报文通过不同的端口向下交到运输层，再往下就共用网络层提供的服务。
- “运输层提供应用进程间的逻辑通信”。“逻辑通信”的意思是：运输层之间的通信好像是沿水平方向传送数据。但事实上这两个运输层之间并没有一条水平方向的物理连接。

## 运输层协议和网络层协议的主要区别

- IP协议的作用范围：主机与主机之间（提供主机之间的逻辑通信）
- TCP和UDP协议的作用范围：应用进程与应用进程之间（提供进程之间的逻辑通信）

## 运输层的主要功能

- 运输层为应用进程之间**提供端到端的逻辑通信**。
- 运输层还要对收到的报文进行**差错检测**。
- 运输层需要有两种不同的运输协议，即面向连接的TCP和无连接的UDP。

# 两种不同的运输协议：TCP和UDP

- 运输层向高层用户屏蔽了下面网络核心的细节（如网络拓扑、所采用的路由选择协议等），它使应用进程看见的就是好像在两个运输层实体之间有一条端到端的逻辑通信信道。
    - 当运输层采用面向连接的TCP（Transmission Control Protocol）协议时，尽管下面的网络是不可靠的（只提供尽最大努力服务），但这种逻辑通信信道就相当于一条全双工的可靠信道。
    - 当运输层采用无连接的UDP（User Datagram Protocol）协议时，这种逻辑通信信道是一条不可靠信道。
- 两个对等运输实体在通信时传送的数据单位叫作运输协议数据单元TPDU（Transport Protocol Data Unit）。
    - TCP传送的数据单位协议是TCP报文段（segment）
    - UDP传送的数据单位协议是UDP报文或用户数据报。
- 建立连接
    - UDP在传送数据之前不需要先建立连接。对方的运输层在收到UDP报文后，不需要给出任何确认。虽然UDP不提供可靠交付，但在某些情况下UDP是一种最有效的工作方式。
    - TCP则提供面向连接的服务。TCP不提供广播或多播服务。由于TCP要提供可靠的、面向连接的运输服务，因此不可避免地增加了许多的开销。这不仅使协议数据单元的首部增大很多，还要占用许多的处理机资源。
- 运输层的UDP用户数据报与网际层的IP数据报有很大区别。IP数据报要经过互连网中许多路由器的存储转发，但UDP用户数据报是在运输层的端到端抽象的逻辑信道中传送的。
- TCP报文段是在运输层抽象的端到端逻辑信道中传送，这种信道是可靠的全双工信道。但这样的信道却不知道究竟经过了哪些路由器，而这些路由器也根本不知道上面的运输层是否建立了TCP连接。

# 运输层的端口

## 使用端口的原因

- 运行在计算机中的进程是用进程标识符来标志的。
- 运行在应用层的各种应用进程却不应当让计算机操作系统指派它的进程标识符。这是因为在因特网上使用的计算机的操作系统种类很多，而不同的操作系统又使用不同格式的进程标识符。
- 为了使运行不同操作系统的计算机的应用进程能够互相通信，就必须用统一的方法对TCP/IP体系的应用进程进行标志。

## 需要解决的问题

- 由于进程的创建和撤销都是动态的，发送方几乎无法识别其他机器上的进程。
- 有时我们会改换接收报文的进程，但并不需要通知所有发送方。
- 我们往往需要利用目的主机提供的功能来识别终点，而不需要知道实现这个功能的进程。

## 端口号（protocol port number）

- 简称为端口（port）。
- 虽然通信的终点是应用进程，但我们可以把端口想象是通信的终点，因为我们只要把要传送的报文交到目的主机的某一个合适的目的端口，剩下的工作（即最后交付目的进程）就由TCP来完成。

### 软件端口与硬件端口

- 在协议栈层间的抽象的协议端口是软件端口。
- 路由器或交换机上的端口是硬件端口。
- 硬件端口是不同硬件设备进行交互的接口，而软件端口是应用层的各种协议进程与运输实体进行层间交互的一种地址。

### TCP端口

- 端口用一个16位端口号进行标志。
- 端口号只具有本地意义，即端口号只是为了标志本计算机应用层中的各进程。在因特网中不同计算机的相同端口号是没有联系的。

### 三类端口

- 熟知端口：数值一般为0~1023。
- 登记端口号：数值为1024~49151，为没有熟知端口号的应用程序使用的。使用这个范围的端口号必须在IANA登记，以防止重复。
- 客户端口号或短暂端口号：数值为49152~65535，留给客户进程选择暂时使用。当服务器    - 进程收到客户进程的报文时，就知道了客户进程所使用的动态端口号。通信结束后，这个端口号可供其他客户进程以后使用。

# UDP

- UDP只在IP的数据报服务之上增加了很少一点的功能，即端口的功能和差错检测的功能。
- 虽然UDP用户数据报只能提供不可靠的交付，但UDP在某些方面有其特殊的优点。
- UDP主要特点
    - UDP是无连接的，即发送数据之前不需要建立连接。
    - UDP使用尽最大努力交付，即不保证可靠交付，同时也不使用拥塞控制。
    - UDP是面向报文的。UDP没有拥塞控制，很适合多媒体通信的要求。
    - UDP支持一对一、一对多、多对一和多对多的交互通信。
    - UDP的首部开销小，只有8个字节

## 面向报文的UDP

![面向报文的UDP](../../resource/img/计算机网络/033.png)

- 发送方UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。
- 应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。
- 接收方UDP对IP层交上来的UDP用户数据报，在去除首部后就原封不动地交付上层的应用进程，一次交付一个完整的报文。
- 应用程序必须选择合适大小的报文。

## UDP首部

![UDP首部](../../resource/img/计算机网络/034.png)

- 伪首部：在计算检验和时，临时把 “伪首部” 和UDP用户数据报连接在一起。伪首部仅仅是为了计算检验和。

# TCP

## TCP最主要的特点

- TCP是面向连接的运输层协议。
- 每一条TCP连接只能有两个端点（endpoint），每一条TCP连接只能是点对点的（一对一）。
- TCP提供可靠交付的服务。
- TCP提供全双工通信。
- 面向字节流。
    ![TCP面向字节流](../../resource/img/计算机网络/035.png)
- 注意：
    - TCP连接是一条虚连接而不是一条真正的物理连接。
    - TCP对应用进程一次把多长的报文发送到TCP的缓存中是不关心的。
    - TCP根据对方给出的窗口值和当前网络拥塞的程度来决定一个报文段应包含多少个字节（UDP发送的报文长度是应用进程给出的）。
    - TCP可把太长的数据块划分短一些再传送。TCP也可等待积累有足够多的字节后再构成报文段发送出去。

## TCP的连接

- TCP把连接作为最基本的抽象。
- 每一条TCP连接有两个端点。
- TCP连接的端点不是主机，不是主机的IP地址，不是应用进程，也不是运输层的协议端口。TCP连接的端点叫做套接字（socket）或插口。
- 端口号拼接到（contatenated with）IP地址即构成了套接字。
    - 套接字socket =（IP地址: 端口号）
    - TCP连接 ::= {socket1, socket2} = {（IP1: port1）,（IP2: port2）}

## TCP首部

![TCP首部](../../resource/img/计算机网络/041.png)

- 源端口和目的端口：各占2字节。端口是运输层与应用层的服务接口。运输层的复用和分用功能都要通过端口才能实现。
- 序号字段：占4字节。TCP连接中传送的数据流中的每一个字节都编上一个序号。序号字段的值则指的是本报文段所发送的数据的第一个字节的序号。
- 确认号字段：占4字节，是期望收到对方的下一个报文段的数据的第一个字节的序号。
- 数据偏移（即首部长度）：占4位，它指出TCP报文段的数据起始处距离TCP报文段的起始处有多远。“数据偏移”的单位是32位字（以4字节为计算单位）。
- 保留字段：占6位，保留为今后使用，但目前应置为0
- 紧急URG：当URG = 1时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快传送（相当于高优先级的数据）。
- 确认ACK：只有当ACK = 1时确认号字段才有效。当ACK = 0时，确认号无效。
- 推送PSH（PuSH）：接收TCP收到PSH = 1的报文段，就尽快地交付接收应用进程，而不再等到整个缓存都填满了后再向上交付。
- 复位RST（ReSeT）：当RST = 1时，表明TCP连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接。
- 同步SYN：同步SYN = 1表示这是一个连接请求或连接接受报文。
- 终止FIN（FINis）：用来释放一个连接。FIN1表明此报文段的发送端的数据已发送完毕，并要求释放运输连接。
- 窗口字段：占2字节，用来让对方设置发送窗口的依据，单位为字节。
- 检验和：占2字节。检验和字段检验的范围包括首部和数据这两部分。在计算检验和时，要在TCP报文段的前面加上12字节的伪首部
- 紧急指针字段：占16位，指出在本报文段中紧急数据共有多少个字节（紧急数据放在本报文段数据的最前面）。
- 选项字段：长度可变。
    - TCP最初只规定了一种选项，即最大报文段长度MSS。MSS告诉对方TCP：“我的缓存所能接收的报文段的数据字段的最大长度是MSS个字节。”
        - MSS（Maximum Segment Size）是TCP报文段中的数据字段的最大长度。数据字段加上TCP首部才等于整个的TCP报文段。
    - 窗口扩大选项：占3字节，其中有一个字节表示移位值S。新的窗口值等于TCP首部中的窗口位数增大到（16 + S），相当于把窗口值向左移动S位后获得实际的窗口大小。
    - 时间戳选项：占10字节，其中最主要的字段时间戳值字段（4字节）和时间戳回送回答字段（4字节）。
    - 选择确认选项
- 填充字段 —— 这是为了使整个首部长度是4字节的整数倍。

# TCP可靠传输工作原理

## 停止等待协议

![停止等待协议1](../../resource/img/计算机网络/036.png)
![停止等待协议2](../../resource/img/计算机网络/037.png)

### 特点

- 在发送完一个分组后，必须暂时保留已发送的分组的副本。
- 分组和确认分组都必须进行编号。
- 超时计时器的重传时间应当比数据在分组传输的平均往返时间更长一些

### 可靠通信的实现

- 使用上述的确认和重传机制，我们就可以在不可靠的传输网络上实现可靠的通信。
- 这种可靠传输协议常称为 **自动重传请求ARQ**（Automatic Repeat reQuest）。
- ARQ表明重传的请求是自动进行的。接收方不需要请求发送方重传某个出错的分组。

### 信道利用率

停止等待协议的优点是简单，但缺点是信道利用率太低。
![停止等待协议信道利用率](../../resource/img/计算机网络/038.png)

- $U = \frac{T_0}{T_D + RTT + T_A}$

## 连续ARQ协议

### 流水线传输

![](../../resource/img/计算机网络/039.png)

- 发送方可连续发送多个分组，不必每发完一个分组就停顿下来等待对方的确认。
- 由于信道上一直有数据不间断地传送，这种传输方式可获得很高的信道利用率。

### 连续ARQ协议

![连续ARQ协议](../../resource/img/计算机网络/040.png)

- 接收方一般采用 **累积确认** 的方式。即不必对收到的分组逐个发送确认，而是对按序到达的最后一个分组发送确认，这样就表示：到这个分组为止的所有分组都已正确收到了。
- 累积确认有的优点是：容易实现，即使确认丢失也不必重传。缺点是：不能向发送方反映出接收方已经正确收到的所有分组的信息。
- Go-back-N（回退N）
    - 如果发送方发送了前5个分组，而中间的第3个分组丢失了。这时接收方只能对前两个分组发出确认。发送方无法知道后面三个分组的下落，而只好把后面的三个分组都再重传一次。
    - 这就叫做Go-back-N（回退N），表示需要再退回来重传已发送过的N个分组。
- 可见当通信线路质量不好时，连续ARQ协议会带来负面的影响。

## TCP可靠通信的具体实现

- TCP连接的每一端都必须设有两个窗口。一个发送窗口和一个接收窗口。
- TCP的可靠传输机制用字节的序号进行控制。TCP所有的确认都是基于序号而不是基于报文段。
- TCP两端的四个窗口经常处于动态变化之中。
- TCP连接的往返时间RTT也不是固定不变的。需要使用特定的算法估算较为合理的重传时间。

### 以字节为单位的滑动窗口

- 根据B给出的窗口值，A构造出自己的发送窗口
- A向B连续放松窗口中的数据。A的发送窗口内的序号都已用完，但还没有再收到确认，必须停止发送
- A收到新的确认号，发送窗口向前滑动

### 发送缓存和接收缓存

- 发送缓存用来暂时存放：
    ![发送缓存](../../resource/img/计算机网络/042.png)
    - 发送应用程序传送给发送方TCP准备发送的数据；
    - TCP已发送出但尚未收到确认的数据。
- 接收缓存用来暂时存放：
    ![接收缓存](../../resource/img/计算机网络/043.png)
    - 按序到达的、但尚未被接收应用程序读取的数据；
    - 不按序到达的数据。
- 注意：
    - A的发送窗口并不总是和B的接收窗口一样大（因为有一定的时间滞后）。
    - TCP标准没有规定对不按序到达的数据应如何处理。通常是先临时存放在接收窗口中，等到字节流中所缺少的字节收到后，再按序交付上层的应用进程。
    - TCP要求接收方必须有累积确认的功能，这样可以减小传输开销。

## 超时重传时间的选择

- 重传机制是TCP中最重要和最复杂的问题之一。
- TCP每发送一个报文段，就对这个报文段设置一次计时器。只要计时器设置的重传时间到但还没有收到确认，就要重传这一报文段。

### 加权平均往返时间

- TCP保留了$RTT$的一个加权平均往返时间$RTT_S$（这又称为平滑的往返时间）。
- 第一次测量到$RTT$样本时，$RTT_S$值就取为所测量到的$RTT$样本值。以后每测量到一个新的$RTT$样本，就按下式重新计算一次$RTT_S$：
- $新的RTT_S = (1 - \alpha) \times 旧的RTT_S + \alpha \times 新的RTT样本$
    - 式中，0 <$\alpha$<1。若$\alpha$很接近于零，表示$RTT$值更新较慢。若选择$\alpha$接近于1，则表示$RTT$值更新较快。
    - RFC 2988推荐的$\alpha$值为1/8，即0.125。

### 超时重传时间RTO（RetransmissionTime-Out）

- $RTO$应略大于上面得出的加权平均往返时间$RTT_S$。
- RFC 2988建议使用下式计算RTO：$RTO = RTT_S + 4 \times RTT_D$
    - $RTT_D$是$RTT$的偏差的加权平均值。
- RFC 2988建议这样计算$RTT_D$。第一次测量时，$RTT_D$值取为测量到的$RTT$样本值的一半。在以后的测量中，则使用下式计算加权平均的$RTT_D$
    - $新的RTT_D =（1 - \beta）\times（旧的RTT_D）+ \beta \times |RTT_S - 新的RTT样本 |$
    - $\beta$是个小于1的系数，其推荐值是1/4，即0.25。

### Karn算法

- 在计算平均往返时间$RTT$时，只要报文段重传了，就不采用其往返时间样本。
- 这样得出的加权平均平均往返时间$RTT_S$和超时重传时间$RTO$就较准确。
- 报文段每重传一次，就把$RTO$增大一些：
- $新的RTO = \gamma \times（旧的RTO）$
    - 系数$\gamma$的典型值是2。
- 当不再发生报文段的重传时，才根据报文段的往返时延更新平均往返时延$RTT$和超时重传时间$RTO$的数值。
- 实践证明，这种策略较为合理。

## 选择确认SACK（Selective ACK）

- 接收方收到了和前面的字节流不连续的两个字节块。
- 如果这些字节的序号都在接收窗口之内，那么接收方就先收下这些数据，但要把这些信息准确地告诉发送方，使发送方不要再重复发送这些已收到的数据。
- 如果要使用选择确认，那么在建立TCP连接时，就要在TCP首部的选项中加上 “允许SACK” 的选项，而双方必须都事先商定好。
- 如果使用选择确认，那么原来首部中的 “确认号字段” 的用法仍然不变。只是以后在TCP报文段的首部中都增加了SACK选项，以便报告收到的不连续的字节块的边界。
    ![SACK实例](../../resource/img/计算机网络/044.png)
- 由于首部选项的长度最多只有40字节，而指明一个边界就要用掉4字节，因此在选项中最多只能指明4个字节块的边界信息。

# TCP流量控制

## 利用滑动窗口实现流量控制

- 一般说来，我们总是希望数据传输得更快一些。但如果发送方把数据发送得过快，接收方就可能来不及接收，这就会造成数据的丢失。
- 流量控制（flow control）就是让发送方的发送速率不要太快，既要让接收方来得及接收，也不要使网络发生拥塞。
- 利用滑动窗口机制可以很方便地在TCP连接上实现流量控制。

## 持续计时器（persistence timer）

- TCP为每一个连接设有一个持续计时器。
- 只要TCP连接的一方收到对方的零窗口通知，就启动持续计时器。
- 若持续计时器设置的时间到期，就发送一个零窗口探测报文段（仅携带1字节的数据），而对方就在确认这个探测报文段时给出了现在的窗口值。
- 若窗口仍然是零，则收到这个报文段的一方就重新设置持续计时器。
- 若窗口不是零，则死锁的僵局就可以打破了

## 必须考虑传输效率

- 可以用不同的机制来控制TCP报文段的发送时机:
- 第一种机制是TCP维持一个变量，它等于最大报文段长度MSS。只要缓存中存放的数据达到MSS字节时，就组装成一个TCP报文段发送出去。
- 第二种机制是由发送方的应用进程指明要求发送报文段，即TCP支持的推送（push）操作。
- 第三种机制是发送方的一个计时器期限到了，这时就把当前已有的缓存数据装入报文段（但长度不能超过MSS）发送出去。

# 拥塞控制

## 一般原理

- 在某段时间，若对网络中某资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏——产生拥塞（congestion）。
- 出现资源拥塞的条件：对资源需求的总和 > 可用资源
- 若网络中有许多资源同时产生拥塞，网络的性能就要明显变坏，整个网络的吞吐量将随输入负荷的增大而下降。

## 拥塞控制与流量控制

- **拥塞控制** 所要做的都有一个前提，就是网络能够承受现有的网络负荷。
- 拥塞控制是一个全局性的过程，涉及到所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素。
- **流量控制** 往往指在给定的发送端和接收端之间的点对点通信量的控制。
- 流量控制所要做的就是抑制发送端发送数据的速率，以便使接收端来得及接收。

## 拥塞控制所起的作用

![拥塞控制所起的作用](../../resource/img/计算机网络/045.png)

## 开环控制和闭环控制

- 开环控制方法就是在设计网络时事先将有关发生拥塞的因素考虑周到，力求网络在工作时不产生拥塞。
- 闭环控制是基于反馈环路的概念。属于闭环控制的有以下几种措施：
    - 监测网络系统以便检测到拥塞在何时、何处发生。
    - 将拥塞发生的信息传送到可采取行动的地方。
    - 调整网络系统的运行以解决出现的问题。

## 几种拥塞控制方法

### 慢开始和拥塞避免

- 发送方维持一个叫做 **拥塞窗口** cwnd（congestion window）的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口。如再考虑到接收方的接收能力，则发送窗口还可能小于拥塞窗口。
- 发送方控制拥塞窗口的原则是：只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。

#### 原理

![慢开始和拥塞避免](../../resource/img/计算机网络/046.png)

- 在主机刚刚开始发送报文段时可先设置拥塞窗口cwnd = 1，即设置为一个最大报文段MSS的数值。
- 在每收到一个对新的报文段的确认后，将拥塞窗口加1，即增加一个MSS的数值。
- 用这样的方法逐步增大发送端的拥塞窗口cwnd，可以使分组注入到网络的速率更加合理。

#### 传输轮次（transmission round）

- 使用慢开始算法后，每经过一个传输轮次，拥塞窗口cwnd就加倍。
- 一个传输轮次所经历的时间其实就是往返时间RTT。
- “传输轮次”更加强调：把拥塞窗口cwnd所允许发送的报文段都连续发送出去，并收到了对已发送的最后一个字节的确认。
- 例如，拥塞窗口cwnd = 4，这时的往返时间RTT就是发送方连续发送4个报文段，并收到这4个报文段的确认，总共经历的时间。

#### 慢开始门限状态变量ssthresh

慢开始门限ssthresh的用法如下：

- 当cwnd < ssthresh时，使用慢开始算法。
- 当cwnd > ssthresh时，停止使用慢开始算法而改用拥塞避免算法。
- 当cwnd = ssthresh时，既可使用慢开始算法，也可使用拥塞避免算法。

#### 拥塞避免算法的思路

- 让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍，使拥塞窗口cwnd按线性规律缓慢增长。
- 当网络出现拥塞时
    - 无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有按时收到确认），就要把慢开始门限ssthresh设置为出现拥塞时的发送方窗口值的一半（但不能小于2）。
    - 然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。
        - 这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完毕
- 乘法减小（multiplicative decrease）
        - 乘法减小“是指不论在慢开始阶段还是拥塞避免阶段，只要出现一次超时（即出现一次网络拥塞），就把慢开始门限值ssthresh设置为当前的拥塞窗口值乘以0.5。
        - 当网络频繁出现拥塞时，ssthresh值就下降得很快，以大大减少注入到网络中的分组数。
- 加法增大（additive increase）
        - “加法增大”是指执行拥塞避免算法后，在收到对所有报文段的确认后（即经过一个往返时间），就把拥塞窗口cwnd增加一个MSS大小，使拥塞窗口缓慢增大，以防止网络过早出现拥塞。

#### 注意事项

- “拥塞避免”并非指完全能够避免了拥塞。利用以上的措施要完全避免网络拥塞还是不可能的。
- “拥塞避免”是说在拥塞避免阶段把拥塞窗口控制为按线性规律增长，使网络比较不容易出现拥塞。

### 快重传和快恢复

#### 快重传

![](../../resource/img/计算机网络/047.png)

- 快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认。这样做可以让发送方及早知道有报文段没有到达接收方。
- 发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段。
- 不难看出，快重传并非取消重传计时器，而是在某些情况下可更早地重传丢失的报文段。

#### 快恢复

- 当发送端收到连续三个重复的确认时，就执行 “乘法减小” 算法，把慢开始门限ssthresh减半。但接下去不执行慢开始算法。
- 由于发送方现在认为网络很可能没有发生拥塞，因此现在不执行慢开始算法，即拥塞窗口cwnd现在不设置为1，而是设置为慢开始门限ssthresh减半后的数值，然后开始执行拥塞避免算法（“加法增大”），使拥塞窗口缓慢地线性增大。
    ![快重传和快恢复](../../resource/img/计算机网络/048.png)
- 随机早期检测RED（Random Early Detection）
- 发送窗口的上限值
    - 发送方的发送窗口的上限值应当取为接收方窗口rwnd和拥塞窗口cwnd这两个变量中较小的一个，即应按以下公式确定：swnd = Min{rwnd, cwnd
    - 当rwnd < cwnd时，是接收方的接收能力限制发送窗口的最大值。
    - 当cwnd < rwnd时，则是网络的拥塞限制发送窗口的最大值。

# TCP的运输连接管理（三次握手，四次挥手）

- 运输连接的三个阶段
    - 连接建立
    - 数据传送
    - 连接释放。
    - 运输连接的管理就是使运输连接的建立和释放都能正常地进行。
- 连接建立过程中要解决以下三个问题：
    - 要使每一方能够确知对方的存在。
    - 要允许双方协商一些参数（如最大报文段长度，最大窗口大小，服务质量等）。
    - 能够对运输实体资源（如缓存大小，连接表中的项目等）进行分配。
- 客户服务器方式
    - TCP连接的建立都是采用客户服务器方式。
    - 主动发起连接建立的应用进程叫做客户（client）。
    - 被动等待连接建立的应用进程叫做服务器（server）。

## TCP建立连接

![](../../resource/img/计算机网络/049.png)

- A的TCP向B发出连接请求报文段，其首部中的同步位SYN = 1，并选择序号seq = x，表明传送数据时的第一个数据字节的序号是x。
- B的TCP收到连接请求报文段后，如同意，则发回确认。B在确认报文段中应使SYN = 1，使ACK = 1，其确认号ack = x + 1，自己选择的序号seq = y。
- A收到此报文段后向B给出确认，其ACK = 1，确认号ack = y + 1。
- A的TCP通知上层应用进程，连接已经建立。
- B的TCP收到主机A的确认后，也通知其上层应用进程：TCP连接已经建立。

## TCP的连接释放

![](../../resource/img/计算机网络/050.png)

- 数据传输结束后，通信的双方都可释放连接。现在A的应用进程先向其TCP发出连接释放报文段，并停止再发送数据，主动关闭TCP连接。A把连接释放报文段首部的FIN = 1，其序号seq = u，等待B的确认。
- B发出确认，确认号ack = u + 1，而这个报文段自己的序号seq = v。
- TCP服务器进程通知高层应用进程。从A到B这个方向的连接就释放了，TCP连接处于半关闭状态。B若发送数据，A仍要接收。
- 若B已经没有要向A发送的数据，其应用进程就通知TCP释放连接。
- A收到连接释放报文段后，必须发出确认。在确认报文段中ACK = 1，确认号ack = w + 1，自己的序号seq = u + 1。
- TCP连接必须经过时间2MSL后才真正释放掉。
    - 第一，为了保证A发送的最后一个ACK报文段能够到达B。
    - 第二，防止 “已失效的连接请求报文段”出现在本连接中。A在发送完最后一个ACK报文段后，再经过时间2MSL，就可以使本连接持续的时间内所产生的所有报文段，都从网络中消失。这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段。

## TCP的有限状态机

![TCP的有限状态机](../../resource/img/计算机网络/051.png)

- 粗实线箭头表示对客户进程的正常变迁。
- 粗虚线箭头表示对服务器进程的正常变迁。
- 另一种细线箭头表示异常变迁。
